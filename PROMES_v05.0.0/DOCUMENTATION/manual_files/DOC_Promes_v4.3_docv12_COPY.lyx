#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass report
\begin_preamble
\usepackage[flushleft]{threeparttable}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{enumitem}

\usepackage{graphicx}

\usepackage[numbered,framed]{matlab-prettifier}

\usepackage{dirtree}

\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000

% new chapter does not start on new page
\usepackage{etoolbox}
\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\makeatother

\usepackage{arydshln}%for dashed line in matrix

% chapter title in format:
% 1 Chapter_title
\usepackage{titlesec}

\titleformat{\chapter}[block]
  {\normalfont\huge\bfseries}{\thechapter.}{1em}{\Huge}
\titlespacing*{\chapter}{0pt}{19pt plus 6pt minus 3pt}{10pt}

\counterwithout{footnote}{chapter}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex-natbib
\cite_engine_type authoryear
\biblio_style plain
\biblatex_bibstyle authoryear
\biblatex_citestyle authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=single,style={Matlab-editor}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage} 	
\end_layout

\begin_layout Plain Layout


\backslash
centering 	
\end_layout

\begin_layout Plain Layout


\backslash
vspace{4cm} 
\end_layout

\begin_layout Plain Layout

{
\backslash
Huge 
\backslash
bfseries 
\backslash
scshape Manual for 
\backslash
par} 
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.5cm}	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=0.25]{FIGURES/LOGO}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.35cm} 	
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

{
\backslash
huge 
\backslash
itshape a projection method solver 
\backslash
par}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.15cm} 
\end_layout

\begin_layout Plain Layout

{
\backslash
huge 
\backslash
itshape for Matlab} 	
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
vspace{2.5cm} 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE Sijmen Duineveld}
\end_layout

\begin_layout Plain Layout

%
\backslash
vspace{1.5cm}  
\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

{
\backslash
Large 
\backslash
textsf{Promes, version 04.3}
\backslash
par
\end_layout

\begin_layout Plain Layout


\backslash
textsf{August 7, 2021}} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Manual
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
The
\family typewriter
 Promes
\family default
 toolbox solves Dynamic Stochastic General Equilibrium models using projection
 methods.
 
\family typewriter
Promes
\family default
 is an acronym for 
\bar under
Pro
\bar default
jection 
\bar under
me
\bar default
thod 
\bar under
s
\bar default
olver.
 The toolbox is written for Matlab, and tested with Matlab 2016b.
 
\end_layout

\begin_layout Standard
With good starting values the solution for a standard Real Business Cycle
 (RBC) model is obtained in between 0.2 and 0.7 second
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For a model with 1 control variable, 2 state variables, 5 Gauss-Hermite
 nodes, and calculated on a desktop with a Ryzen 2700x processor.
 The initial guess for the policy function is the first order perturbation
 solution.
\end_layout

\end_inset

.
 The toolbox offers the options to approximate policy functions with either
 a spline, complete Chebyshev polynomials, or a complete polynomial using
 monomial basis functions.
 The spline solution can be obtained using Time iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) or Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

).
 For the Chebyshev polynomials the coefficients can be determined using
 Galerkin's method (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

) or Minimization of the Squared Errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

).
 For the monomial basis functions (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

) the squared errors are minimized as well.
 Details of the methods are explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Solving-the-model"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Core of the toolbox
\end_layout

\begin_layout Standard
Three functions form the core of the toolbox, and understanding them is
 crucial to coding and solving a model with the 
\family typewriter
Promes
\family default
 toolbox.
 The first function is 
\family typewriter
prep_grid
\family default
, which constructs a grid taking the grid parameters and the solution method
 as input.
 The second is 
\family typewriter
get_pol_var
\family default
, which evaluates the policy function taking the state variables as input.
 This function simplifies programming the model file and simulations.
 The third is 
\family typewriter
solve_proj
\family default
, which solves the model, given the solution method, an initial guess, and
 the grid.
 The initial guess for the policy function should give the policy variables
 at the gridpoints.
 The toolbox will internally construct the appropriate policy function,
 either a spline or polynomial.
 These three main functions are found in the main folder `PROMES_v04.3' and
 are explained in Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "part:Function-descriptions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
With these three functions solving a DSGE model with projection methods
 becomes relatively easy.
 The main remaining task for the modeler is to program the model function.
 The model function has to compute the residuals of the objective function,
 given a grid and the policy function.
 The requirements for a model file are explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 When the method Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) is used one has to pay special attention to the format of the model function
 (see Time Iteration in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-'solve_proj'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Section
Getting started
\end_layout

\begin_layout Standard
To get started with the toolbox it is recommended to go through the examples.
 The program code of these examples can be found in the folder `PROMES_v04.3
\backslash
Examples'.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Proj_intro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 gives an introduction to projection methods, and explains the basics features
 of the toolbox.
 It describes a very simple non-recursive model, which is solved in the
 program 
\family typewriter
main_lc2_proj
\family default
.
 This example also plots the exact solution and the projection approximation.
\end_layout

\begin_layout Standard
For those familiar with projection methods it is recommended to start with
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:The-Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which describes a 6-step procedure to solve a model with the 
\family typewriter
Promes
\family default
 toolbox.
 This procedure is explained with a simple recursive model, the deterministic
 Brock-Mirman model.
 The program 
\family typewriter
main_det_bm_proj 
\family default
solves this model following the six steps.
 This program also plots the policy function, and the errors.
 
\end_layout

\begin_layout Standard
A more detailed step-by-step guide can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which is based on a standard Real Business Cycle (RBC) model with stochastic
 shocks.
 The code for this model is the script 
\family typewriter
main_stnd_rbc_proj
\family default
.
 As in the previous example the program will plot the policy function.
 In addition it will plot two stochastic simulations.
 
\end_layout

\begin_layout Standard
The last example is the program 
\family typewriter
main_housing_proj
\family default
, which shows how to solve a model with multiple policy functions.
 It is very similar to the RBC model discussed earlier, but includes housing
 as an extra asset.
 
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
For the installation download the `Promes_v04.3.zip' file from the website
 
\begin_inset CommandInset href
LatexCommand href
name "https://www.saduineveld.com/tools"
target "https://www.saduineveld.com/tools"
literal "false"

\end_inset

, and unpack it in a folder.
 This will add the folders `PROMES_v04.3' and `TOOLS' to the destination
 folder.
 The folders and files of the 
\family typewriter
Promes
\family default
 toolbox are in the folder `PROMES_v04.3' and are shown in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Promes_struct}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In order to use the 
\family typewriter
Promes
\family default
 toolbox one needs to add the folder `PROMES_v04.3' and the subfolder `grid_subfu
n' to the search path.
 After unpacking the 
\family typewriter
zip
\family default
 file in the folder `C:
\backslash
Myfolder' one can add `PROMES_v04.3' and all its subfolders to the searchpath
 with the Matlab command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

addpath(genpath('C:
\backslash
Myfolder
\backslash
PROMES_v04.3'));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The folder `PROMES_v04.3' also has a subfolder `Examples' which contains
 five examples:
\end_layout

\begin_layout Itemize

\family typewriter
main_lc2_proj
\family default
 explains the basics of projection methods, and the main features of the
 toolbox in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Proj_intro"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
grid_example
\family default
 illustrates the construction of the grid, and is explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
main_det_bm_proj
\family default
 demonstrates a basic procedure for using the toolbox as described in Chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:The-Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with a very simple model, the deterministic Brock-Mirman model;
\end_layout

\begin_layout Itemize

\family typewriter
main_stand_rbc_proj
\family default
 demonstrates some details of using the toolbox as described in Chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with a more complex model, a standard RBC model with stochastic shocks.
 The subfolder `PROMES_v04.3/Examples/STND_RBC_mod' contains functions needed
 to solve that model;
\end_layout

\begin_layout Itemize

\family typewriter
main_housing_proj
\family default
 shows how to solve a model with multiple policy functions as described
 in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with an RBC model that includes housing as an extra asset.
 
\end_layout

\begin_layout Standard
The examples 
\family typewriter
main_stand_rbc_proj
\family default
 and 
\family typewriter
main_housing_proj
\family default
 require the addition of the folder `TOOLS' to the searchpath.
 This folder contains the function 
\family typewriter
hernodes
\family default
, and the toolbox 
\family typewriter
CSD
\family default
 to obtain an initial guess for the policy function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
DTstyle}{
\backslash
textrm
\backslash
expandafter
\backslash
raisebox{-0.7ex}} 
\end_layout

\begin_layout Plain Layout


\backslash
DTsetlength{1em}{1em}{0.2em}{0.4pt}{0.4pt} 
\end_layout

\begin_layout Plain Layout


\backslash
setlength{
\backslash
DTbaselineskip}{1.4
\backslash
baselineskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
texttt{PROMES} folders and files} 
\end_layout

\begin_layout Plain Layout


\backslash
label{fig:Promes_struct} 
\end_layout

\begin_layout Plain Layout


\backslash
dirtree{%  
\end_layout

\begin_layout Plain Layout

.1 Folder: PROMES
\backslash
_v04.3.
  
\end_layout

\begin_layout Plain Layout

.2 
\backslash
texttt{prep
\backslash
_grid.m}.
  
\end_layout

\begin_layout Plain Layout

.2 
\backslash
texttt{get
\backslash
_pol
\backslash
_var.m}.
  
\end_layout

\begin_layout Plain Layout

.2 
\backslash
texttt{solve
\backslash
_proj.m}.
   
\end_layout

\begin_layout Plain Layout

.2 Folder: grid
\backslash
_subfun.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{chebnodes.m}.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{constr
\backslash
_grid.m}.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{constr
\backslash
_vecs.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{grid
\backslash
_struct.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{polybase.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_cheb
\backslash
_dw.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_cheb
\backslash
_up.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_mat
\backslash
_dw.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_mat
\backslash
_up.m}.
  
\end_layout

\begin_layout Plain Layout

.2 Folder: Examples.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{grid
\backslash
_example.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_det
\backslash
_bm
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_housing
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_lc2
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_stnd
\backslash
_rbc
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.3 Folder: STND
\backslash
_RBC
\backslash
_mod.
 
\end_layout

\begin_layout Plain Layout

.4 
\backslash
texttt{plot
\backslash
_stnd
\backslash
_rbc.m}.
 
\end_layout

\begin_layout Plain Layout

.4 
\backslash
texttt{stnd
\backslash
_rbc
\backslash
_aux.m}.
 
\end_layout

\begin_layout Plain Layout

.4 
\backslash
texttt{STND
\backslash
_RBC
\backslash
_pert.m}.
 
\end_layout

\begin_layout Plain Layout

.4 
\backslash
texttt{STND
\backslash
_RBC
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.4 
\backslash
texttt{stnd
\backslash
_rbc
\backslash
_sim.m} 
\end_layout

\begin_layout Plain Layout

.4 
\backslash
texttt{stnd
\backslash
_rbc
\backslash
_ss.m}.
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Recommendations
\end_layout

\begin_layout Standard
In general we would recommend the Chebyshev methods Minimization of Squared
 Errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

), and Galerkin (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

) as both are accurate and fast as shown in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Performance_RBC"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 In two cases one of the spline methods should be preferred, so either Time
 Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) or Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
The first case is when it is difficult to obtain a good initial guess for
 the policy function.
 Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) should then be preferred, because it is the only method that theoretically
 converges to the stable solution 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1998numerical"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
The second case is when one expects the shape of the policy function to
 be poorly approximated with a polynomial.
 For example, the stable manifold of models featuring an attracting limit
 cycle is better approximated with a spline.
 
\end_layout

\begin_layout Standard
Direct Computation should be preferred over Time Iteration when convergence
 is not an issue, and the number of gridpoints is relatively low
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The Standard RBC model and the Housing model indicate Direct Computation
 is faster for less than about 300 gridpoints.
\end_layout

\end_inset

.
 In those cases Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

) is likely to be faster than Time Iteration, and achieves similar accuracy.
 
\end_layout

\begin_layout Standard
The method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, which minimizes the sum of the squared errors using monomial basis functions,
 is not recommended.
 This method is only included for demonstration purposes.
\end_layout

\begin_layout Standard
For polynomials the addition of gridpoints increases the accuracy only marginall
y, and we therefore recommend the use of the minimum amount of gridpoints
 for polynomial approximations.
 For this toolbox the minimum amount of gridpoints for an order 
\begin_inset Formula $r$
\end_inset

 approximation is 
\begin_inset Formula $r+1$
\end_inset

 gridpoints in each dimension.
 
\end_layout

\begin_layout Standard
For the methods using splines numerical tests indicate that the errors are
 most of all caused by interpolation, since the errors at gridpoints are
 much smaller than off gridpoints.
 Setting the stopping criteria tighter will therefore have little effect
 on the overall accuracy.
 For splines adding gridpoints will increase the accuracy as interpolation
 errors will become smaller.
 However, a small number of nodes in each dimension (around 5-7) might suffice
 to achieve acceptable accuracy levels.
\end_layout

\begin_layout Section
Remarks
\end_layout

\begin_layout Subsection*
Matlab toolboxes
\end_layout

\begin_layout Standard
All methods require Matlab's 
\family typewriter
Optimization
\family default
 
\family typewriter
toolbox
\family default
.
 We use 
\family typewriter
fsolve
\family default
 for methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

.
 We use 
\family typewriter
lsqnonlin
\family default
 for methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

.
 Alternatively one could use his/her own equation solver or minimization
 routine.
 
\end_layout

\begin_layout Subsection*
Notes on typesetting
\end_layout

\begin_layout Standard
Names in general are referred to by single quotations, like a folder name
 `Myfolder'.
 Variables, cell arrays, structure names, fields of structures, objects,
 and properties of objects in Matlab are referred to in the text with the
 mathematical font of Latex, for example variable 
\begin_inset Formula $x$
\end_inset

, structure 
\begin_inset Formula $par$
\end_inset

 or the field of a structure 
\begin_inset Formula $par.alpha$
\end_inset

.
 In general we use double letters in our programs such as 
\begin_inset Formula $xx$
\end_inset

, because this makes it easier to find them in a file.
 In this documentation we generally refer to variables by the single letter
 (
\begin_inset Formula $x$
\end_inset

).
 Strings in Matlab code will be referred to in Matlab typesetting, for example
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'thisstring'}
\end_layout

\end_inset

.
 Names referring to toolboxes, code, functions or scripts are in Typewriter
 font, as in 
\family typewriter
myfunction
\family default
, where the 
\family typewriter
.m
\family default
 extension of functions and scripts will be omitted for simplicity.
\end_layout

\begin_layout Subsection*
Scripts versus functions
\end_layout

\begin_layout Standard
There are two main differences between a function and a script in Matlab.
 The first is that one cannot define a subfunction in a script.
 The second is that a script will use the current workspace, while a function
 has its own workspace, which is empty unless input arguments are defined
 or global variables are used
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Global variables are not recommended for Matlab.
\end_layout

\end_inset

.
 When using a function one can evaluate the variables in the workspace by
 placing a breakpoint, for example just before the end of the code.
\end_layout

\begin_layout Standard
The toolbox consists of functions, and most examples are also functions
 except for the files 
\family typewriter
grid_example 
\family default
and
\family typewriter
 main_stnd_rbc_proj
\family default
.
 For the latter example we call all subfunctions externally from the subfolder
 `STND_RBC_mod'.
 In the other examples all subfunctions are included in the main file.
 
\end_layout

\begin_layout Subsection*
Sources
\end_layout

\begin_layout Standard
This toolbox is largely based on three sources.
 For the method Time Iteration we used 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

 and Wouter den Haan's material on his website 
\begin_inset CommandInset href
LatexCommand href
target "www.wouterdenhaan.com"
literal "false"

\end_inset

.
 For the methods based on polynomials we used 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

, and 
\begin_inset CommandInset citation
LatexCommand citet
key "heer2009dynamic"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Subsection*
Acknowledgments
\end_layout

\begin_layout Standard
I would like to thank Wouter den Haan, Joris de Wind and Petr Sedlacek for
 the courses on solving DSGE models at the Tinbergen Institute.
 I would also like to thank Alfred Maussner, Christopher Heiberger, and
 Daniel Fehrle at the University of Augsburg for various discussions on
 solving DSGE models, and writing this toolbox.
 The method Direct Computation is an idea of Christopher Heiberger.
\end_layout

\begin_layout Subsection*
Feedback
\end_layout

\begin_layout Standard
All feedback is more than welcome at 
\begin_inset CommandInset href
LatexCommand href
name "s.a.duineveld@outlook.com"
target "s.a.duineveld@outlook.com"
literal "false"

\end_inset

.
\end_layout

\begin_layout Chapter
Introduction to projection methods
\begin_inset CommandInset label
LatexCommand label
name "chap:Proj_intro"

\end_inset


\end_layout

\begin_layout Standard
Projection methods are used to approximate an unknown function.
 We will explain the basic principle of all methods with a simple 2-period
 life-cycle model, called the Simple Life Cycle model.
 This simple model has 
\begin_inset Formula $C\left(x\right)=e^{x}$
\end_inset

 as its solution
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
key "judd1998numerical"
literal "false"

\end_inset

 also approximates 
\begin_inset Formula $e^{x}$
\end_inset

, but he derives it from a differential equation and imposes an initial
 condition.
 We use a simple discrete time model.
 It should be emphasized that the model does not have the recursive structure
 of infinite horizon problems, which oversimplifies some aspects.
 The other examples in this manual have the recursive structure.
\end_layout

\end_inset

.
 The program that solves this model is the function 
\family typewriter
main_lc2_proj
\family default
 in the folder `PROMES_v04.3/Examples'.
 
\end_layout

\begin_layout Section
Simple Life Cycle model
\end_layout

\begin_layout Standard
The objective of the agent is to maximize utility derived from consumption
 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $C_{2}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max_{C,C_{2}} & \:U\left(C\right)+U\left(C_{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The optimization is subject to the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{2} & =2e^{x}-C\label{eq:SMPL_budget}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $x$
\end_inset

 is the capital stock at the beginning of the first period.
 
\end_layout

\begin_layout Standard
With the Constant Relative Risk Aversion (CRRA) utility function 
\begin_inset Formula $U\left(C\right)=\frac{C_{t}^{1-\nu}-1}{1-\nu}$
\end_inset

 and restricting 
\begin_inset Formula $C\geq0$
\end_inset

, 
\begin_inset Formula $C_{2}\geq0$
\end_inset

, and 
\begin_inset Formula $\nu>0$
\end_inset

 the First Order Conditions (FOC) are sufficient to define a unique solution
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In most economic problems the model is restricted to be convex such that
 the First Order Conditions are sufficient to obtain a unique solution.
 Note however that dynamic models are usually saddle path stable, which
 means they have both a stable and an unstable solution.
\end_layout

\end_inset

.
 The FOCs yield
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We do not use the standard formulation 
\begin_inset Formula $C^{-\nu}=C_{2}^{-\nu}$
\end_inset

, because in that case the relative errors are larger for higher levels
 of consumption.
 From the perspective of the agent it would be optimal to allow for larger
 errors when consumption is high, due to the risk aversion.
 However, we take the modeler's perspective and prefer more equally distributed
 errors.
 To analyze the effect on the approximation one can change the residual
 function to 
\begin_inset Formula $C^{-\nu}=C_{2}^{-\nu}$
\end_inset

, and use a second order polynomial for the approximation (by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{POL.order = 2}
\end_layout

\end_inset

).
 The plots will show that the errors will be large for high levels of consumptio
n.
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\left(\frac{C}{C_{2}}\right)^{-\nu} & =1\label{eq:SMPL_FOC}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The system of equations consisting of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_FOC"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

 has the explicit solution 
\begin_inset Formula $C\left(x\right)=e^{x}$
\end_inset

.
\end_layout

\begin_layout Section
Projection explained
\end_layout

\begin_layout Standard
In general 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
projection methods approximate a policy variable as a function of the state
 variables.
 The state variables describe the current state of the economy, and are
 sufficient to determine the future behaviour of the system
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
See 
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/State_variable"

\end_inset

.
\end_layout

\end_inset

.
 In this example 
\begin_inset Formula $x$
\end_inset

 is the state variable, and we choose consumption 
\begin_inset Formula $C$
\end_inset

 as the policy or choice variable.
 The objective of projection methods is to approximate the policy function
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $C\left(x\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
with 
\begin_inset Formula $\hat{C}\left(x;\theta\right)$
\end_inset

, where 
\begin_inset Formula $\theta$
\end_inset

 is a vector of parameters that defines a polynomial or a spline.
 We define a residual function based on 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_FOC"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $C_{2}$
\end_inset

 determined by the budget restriction 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We replace 
\begin_inset Formula $C$
\end_inset

 with the approximation 
\begin_inset Formula $\hat{C}\left(x;\theta\right)$
\end_inset

 such that the residuals are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(x;\theta\right) & =\left(\frac{\hat{C}\left(x;\theta\right)}{2e^{x}-\hat{C}\left(x;\theta\right)}\right)^{-\nu}-1\label{eq:SMPL_RES}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The objective of projection methods is to find the approximation that minimizes
 the residual function 
\begin_inset Formula $R$
\end_inset

 by setting 
\begin_inset Formula $\theta$
\end_inset

.
 
\end_layout

\begin_layout Standard
First we have to choose some interval 
\begin_inset Formula $lb\leq x\leq ub$
\end_inset

 of the state variable, where we want to approximation to be good
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
.
 We select a limited number of grid points 
\begin_inset Formula $x=\left[x_{1},x_{2},\ldots,x_{m}\right]^{\intercal}$
\end_inset

 on this interval.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
We call this vector the initial grid, and it will be stored in 
\begin_inset Formula $GRID.xx$
\end_inset

 by the function 
\family typewriter
prep_grid
\family default
.
 We want to emphasize that the modeler does not have to construct the grid.
 He/she only has to supply the inputs for the grid, consisting of the number
 of state variables 
\begin_inset Formula $n$
\end_inset

, the lower and upper bounds 
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

, the number of gridpoints 
\begin_inset Formula $q$
\end_inset

, the solution method 
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

, and optionally the order of the approximation for polynomials in the field
 
\begin_inset Formula $order$
\end_inset

.
 The function 
\family typewriter
prep_grid
\family default
 will construct the required fields in the structure 
\begin_inset Formula $GRID$
\end_inset

 with a simple call:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GRID = prep_grid(nn,lb,ub,qq,sol_meth,order);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After constructing the grid we need to calculate the residuals for which
 we use the model function 
\family typewriter
res_lc2
\family default
.
 This subfunction takes the parameters 
\begin_inset Formula $par$
\end_inset

, the grid 
\begin_inset Formula $GRID$
\end_inset

 and the structure with the policy function 
\begin_inset Formula $POL$
\end_inset

 as inputs, and gives the residuals 
\begin_inset Formula $RES$
\end_inset

 as output:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% Residual function Simple Life Cycle model 
\end_layout

\begin_layout Plain Layout

function [RES]  = res_lc2(par,GRID,POL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Initial grid of state variable:
\end_layout

\begin_layout Plain Layout

xx = GRID.xx;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Evaluate policy function,
\end_layout

\begin_layout Plain Layout

% at the initial grid:
\end_layout

\begin_layout Plain Layout

if ~strcmp(POL.sol_meth,'tmi') 
\end_layout

\begin_layout Plain Layout

  % standard: log(C) from policy function   
\end_layout

\begin_layout Plain Layout

  CC     = get_pol_var(POL,xx,GRID); 
\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

  % tmi: solver directly sets C_i      
\end_layout

\begin_layout Plain Layout

  % (at gridpoint x_i)       
\end_layout

\begin_layout Plain Layout

  CC    = POL.YY; 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Budget constraint gives C2:
\end_layout

\begin_layout Plain Layout

C2 = 2*exp(xx) - CC;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Euler residuals:
\end_layout

\begin_layout Plain Layout

RES = (CC./C2).^-par.nu - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To compute the residuals we evaluate the approximation of the policy variable
 
\begin_inset Formula $\hat{C}$
\end_inset


\begin_inset Formula $\left(x\right)$
\end_inset

 at the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

, for a given policy function in 
\begin_inset Formula $POL$
\end_inset

.
 There are two options for this.
 For all methods except 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 we call 
\family typewriter
get_pol_var
\family default
 with the state vector 
\begin_inset Formula $x$
\end_inset

 as input (Line 11).
 For the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 we directly evaluate the vector of the policy variable at the gridpoints,
 which is stored in 
\begin_inset Formula $POL.YY$
\end_inset

 by the toolbox (Line 15).
 After calculating 
\begin_inset Formula $C_{2}$
\end_inset

 from the budget constraint in Line 19 we can 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
compute the residuals 
\begin_inset Formula $RES$
\end_inset

 as in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_RES"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The function 
\family typewriter
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
solve_proj
\family default
 computes the policy function 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
that minimizes these residuals.
 The function 
\family typewriter
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
solve_proj
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 will assign the policy function to the structure 
\begin_inset Formula $POL$
\end_inset

.
\end_layout

\begin_layout Standard
We can distinguish two types of policy functions, polynomials and splines.
 The methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 approximate the policy function with polynomials.
 The first uses equidistant nodes, and monomial basis function (
\begin_inset Formula $1,x,x^{2},x^{3},\ldots$
\end_inset

), whereas the other two methods use Chebyshev polynomials.
 The methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 use a spline as defined by 
\family typewriter
griddedInterpolant
\family default
 (see Matlab documentation) with equidistant nodes.
 
\end_layout

\begin_layout Standard
For all methods an initial guess for the policy function needs to be supplied
 as input 
\begin_inset Formula $Y0$
\end_inset

 in the solver 
\family typewriter
solve_proj
\family default
.
 The initial guess 
\begin_inset Formula $Y0$
\end_inset

 is the policy function at the initial grid.
 For our initial guess we use a third order Taylor series of the exact solution
 
\begin_inset Formula $C\left(x\right)=e^{x}$
\end_inset

 around some point 
\begin_inset Formula $\overline{x}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{0}\left(x\right) & =C\left(\overline{x}\right)+\left(x-\overline{x}\right)e^{\overline{x}}+\frac{\left(x-\overline{x}\right)^{2}}{2}e^{\overline{x}}+\frac{\left(x-\overline{x}\right)^{3}}{6}e^{\overline{x}}\label{eq:SMPL_Taylor_series}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Note that in general we approximate an unknown function, which prevents
 us from directly computing a Taylor series approximation.
 However, we can obtain a good initial guess for most models using perturbation
 methods, which is a Taylor series approximation of a system of equations.
\end_layout

\begin_layout Section
Monomial basis function
\begin_inset CommandInset label
LatexCommand label
name "sec:Monomial-basis-function"

\end_inset


\end_layout

\begin_layout Standard
To explain the basics of projection methods we start with the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, which uses monomial basis functions to approximate the function.
 This method is not recommended, but it is easy to understand.
 In our example we use an order 3 monomial.
 The third order monomial basis functions consists of the terms 
\begin_inset Formula $X=\left[\begin{array}{cccc}
1 & x & x^{2} & x^{3}\end{array}\right]$
\end_inset

.
 The third order polynomial approximation of a some function 
\begin_inset Formula $C\left(x\right)$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{C}\left(x;\theta\right) & =\theta_{1}+\theta_{2}x+\theta_{3}x^{2}+\theta_{4}x^{3}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which means 
\begin_inset Formula $\theta$
\end_inset

 consists of 
\begin_inset Formula $p=4$
\end_inset

 coefficients.
 The goal is to set these coefficients such that the approximation is accurate.
\end_layout

\begin_layout Standard
We approximate our objective function over the interval 
\begin_inset Formula $0\leq x\leq3$
\end_inset

, and use 
\begin_inset Formula $q=4$
\end_inset

 equidistant nodes.
 Since the grid consists of only one state variable (
\begin_inset Formula $n=1$
\end_inset

) the total number of grid points 
\begin_inset Formula $m$
\end_inset

 is equal to 
\begin_inset Formula $4$
\end_inset

 as well.
 The polynomial is just identified as the number of grid points is equal
 to the number of polynomial terms (
\begin_inset Formula $m=p$
\end_inset

).
\end_layout

\begin_layout Standard
The grid vector with four nodes is 
\begin_inset Formula $x=\left[\begin{array}{cccc}
0 & 1 & 2 & 3\end{array}\right]^{\intercal}$
\end_inset

, which the function 
\family typewriter
prep_grid
\family default
 assigns to the field 
\begin_inset Formula $GRID.xx$
\end_inset

.
 The complete polynomial 
\begin_inset Formula $X=\left[\begin{array}{cccc}
1 & x & x^{2} & x^{3}\end{array}\right]$
\end_inset

 of this grid is an 
\begin_inset Formula $m$
\end_inset

 x 
\begin_inset Formula $p$
\end_inset

 matrix:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
X & =\left[\begin{array}{cccc}
1 & 0 & 0 & 0\\
1 & 1 & 1 & 1\\
1 & 2 & 4 & 8\\
1 & 3 & 9 & 27
\end{array}\right]
\end{align*}

\end_inset

which is stored in 
\begin_inset Formula $GRID.XX$
\end_inset

 and is printed on screen in the example 
\family typewriter
main_lc2_proj
\family default
.
\end_layout

\begin_layout Standard
With the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 the objective is to minimize the sum of the squared residuals at the grid
 points:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\min_{\theta} & \sum_{i=1}^{m}R\left(x_{i};\theta\right)^{2}\label{eq:MSE_obj_mono}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints.
 The solver 
\family typewriter
solve_proj
\family default
 minimizes the sum of the squared errors by setting 
\begin_inset Formula $\theta$
\end_inset

, which is stored in 
\begin_inset Formula $POL.theta$
\end_inset

.
 The solvers uses Matlab's 
\family typewriter
lsqnonlin
\family default
 of the 
\family typewriter
Optimization Toolbox
\family default
 to find the optimal values of 
\begin_inset Formula $\theta$
\end_inset

.
 As the system is just identified the error at the gridpoints will be (close
 to) zero.
\end_layout

\begin_layout Standard
The resulting third order approximation is plotted in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Mono_proj}
\end_layout

\end_inset

.
 The maximum error in 
\begin_inset Formula $\hat{C}\left(\theta\right)$
\end_inset

 on the interval 
\begin_inset Formula $0\leq x\leq3$
\end_inset

 is 0.26.
 This seems relatively large and reflects that we used a relatively low
 order approximation.
 For comparison we have also included the third order Taylor series approximatio
n (see equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_Taylor_series"
plural "false"
caps "false"
noprefix "false"

\end_inset

) around the point 
\begin_inset Formula $\overline{x}=1.5$
\end_inset

, which we used as an initial guess for the policy function.
 It is clear from the figure that the projection solution does well over
 the whole domain, while the Taylor series is inaccurate away from the point
 
\begin_inset Formula $\overline{x}=1.5$
\end_inset

.
 The maximum error for the third order Taylor series is 3.8.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
3rd order monomial approximation
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:Mono_proj}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ../../PROMES_v04.03/TEXT/FIGURES/mono.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Chebyshev polynomials
\begin_inset CommandInset label
LatexCommand label
name "sec:MSE-with-Chebyshev"

\end_inset


\end_layout

\begin_layout Standard
The method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 is similar to the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 in the previous section as both minimize the sum of the squared errors,
 but the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 differs in two aspects.
 First, it uses Chebyshev polynomials for which variables are mapped into
 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

, and second it uses Chebyshev nodes instead of equidistant nodes
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
These differences favor them over monomial basis functions with equidistant
 nodes.
 See Chapter 6 in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

.
\end_layout

\end_inset

.
 It should be noted that the modeler does not need knowledge of Chebyshev
 polynomials as the toolbox takes care of all the necessary transformations.
 For example, to evaluate the policy function one only needs to supply the
 capital stock 
\begin_inset Formula $x$
\end_inset

 in a column vector, the structure with the policy function 
\begin_inset Formula $POL$
\end_inset

, and the object with the grid (
\begin_inset Formula $GRID$
\end_inset

).
 With these inputs the function 
\family typewriter
get_pol_var
\family default
 will return the policy variable as a column vector.
\end_layout

\begin_layout Standard
For Chebyshev polynomials we use a linear change of variable, such that
 the grid points are mapped from the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 (lower and upper bound) into the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 .
 The linear map is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{x}\left(x;b\right) & =\frac{2x}{ub-lb}-\frac{lb+ub}{ub-lb}\label{eq:Cheb_scal_dw}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}$
\end_inset

 is the scaled down variable, and 
\begin_inset Formula $b$
\end_inset

 refers to the bounds 
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

.
 In our example we use 4 nodes (
\begin_inset Formula $GRID.qq=4$
\end_inset

).
 The Chebyshev nodes are in the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{x} & =\left[\begin{array}{cccc}
-0.924 & -0.383 & 0.383 & 0.924\end{array}\right]^{\intercal}\label{eq:Cheb_x_dw}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
This grid vector is stored in 
\begin_inset Formula $GRID.xx\textrm{\_}dw$
\end_inset

 (see Section 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{sec:Function-sc_cheb_dw}
\end_layout

\end_inset

).
 The scaled up values (see Section 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{sec:Function-sc_cheb_up}
\end_layout

\end_inset

) in the interval 
\begin_inset Formula $\left[0,3\right]$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
x & =\left[\begin{array}{cccc}
0.114 & 0.926 & 2.074 & 2.89\end{array}\right]^{\intercal}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which is stored in 
\begin_inset Formula $GRID.xx$
\end_inset

.
 Note that these nodes are not linearly spaced.
\end_layout

\begin_layout Standard
As with the other polynomial methods we choose a third order approximation.
 The third order Chebyshev polynomial (of the first kind) with one variable
 consists of the terms:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{X} & =\left[\begin{array}{cccc}
1 & \tilde{x} & 2\tilde{x}^{2}-1 & 4\tilde{x}^{3}\end{array}-3\tilde{x}\right]\label{eq:Cheb_X_dw_2nd-1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which is stored as an 
\begin_inset Formula $m$
\end_inset

 x 
\begin_inset Formula $p$
\end_inset

 matrix in the field 
\begin_inset Formula $GRID.XX\textrm{\_}dw$
\end_inset

, where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints and 
\begin_inset Formula $p$
\end_inset

 is the number coefficients in 
\begin_inset Formula $\theta$
\end_inset

.
 In this example we have 
\begin_inset Formula $m=p=4$
\end_inset

 such that the coefficient 
\begin_inset Formula $\theta$
\end_inset

 are just identified.
 The approximation of our objective function given the coefficient vector
 
\begin_inset Formula $\theta$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{C}\left(x;\theta,b\right) & =\theta_{1}+\theta_{2}\tilde{x}+\theta_{3}\left(2\tilde{x}^{2}-1\right)+\theta_{4}\left(4\tilde{x}^{3}-3\tilde{x}\right)\label{eq:SMPL_Cheb_approx}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where we use 
\begin_inset Formula $\tilde{x}$
\end_inset

 as short hand notation for the scaled down variable 
\begin_inset Formula $\tilde{x}\left(x;b\right)$
\end_inset

, where 
\begin_inset Formula $b$
\end_inset

 refers to the lower and upper bounds
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
Note that the coefficients of the polynomial depend on these bounds, due
 to the linear transformation in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_scal_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The objective for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 is the same as for the monomial basis function as in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:MSE_obj_mono"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The solver finds the optimal values of 
\begin_inset Formula $\theta$
\end_inset

 using 
\family typewriter
lsqnonlin
\family default
.
 It should be emphasized that the model function only needs to return the
 residual vector 
\begin_inset Formula $R\left(x_{i};\theta,b\right)$
\end_inset

 as 
\family typewriter
lsqnonlin
\family default
 will square these residuals.
 The resulting coefficients 
\begin_inset Formula $\theta$
\end_inset

 are assigned to 
\begin_inset Formula $POL.theta$
\end_inset

 by the toolbox.
 The third order approximation is plotted in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:MSE_proj}
\end_layout

\end_inset

.
 The maximum error in 
\begin_inset Formula $\hat{C}\left(\theta\right)$
\end_inset

 on the interval 
\begin_inset Formula $0\leq x\leq3$
\end_inset

 is 0.18.
 As before the number of parameters 
\begin_inset Formula $\theta$
\end_inset

 and the number of nodes are the same (
\begin_inset Formula $p=m=4$
\end_inset

) resulting in (close to) zero errors at the gridpoints.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
3nd order Chebyshev approximation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:MSE_proj}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ../../PROMES_v04.03/TEXT/FIGURES/mse.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Galerkin method
\end_layout

\begin_layout Standard
The objective of the Galerkin method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 is to choose each coefficient 
\begin_inset Formula $\theta_{ip}$
\end_inset

 for 
\begin_inset Formula $ip=\left[1,2,\ldots,p\right]$
\end_inset

 in the Chebyshev approximation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_Cheb_approx"
plural "false"
caps "false"
noprefix "false"

\end_inset

, such that the residuals are orthogonal to the corresponding polynomial
 vector 
\begin_inset Formula $\tilde{X}_{ip}$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 (see equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_X_dw_2nd-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Each 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\tilde{X}_{ip}$
\end_inset

 is a column vector
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
of 
\begin_inset Formula $GRID.XX\textrm{\_}dw$
\end_inset

, which is printed on screen when running 
\family typewriter
main_lc2_proj
\family default
.

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 For example when we use the 4 nodes as 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_x_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and take the quadratic term (
\begin_inset Formula $ip=3$
\end_inset

) we get:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\tilde{X}_{3} & =2\tilde{x}^{2}-1\\
 & =\left[\begin{array}{cccc}
0.707 & -0.707 & -0.707 & 0.707\end{array}\right]^{\intercal}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
For each coefficient 
\begin_inset Formula $\theta_{ip}$
\end_inset

 the objective is: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
0 & =\sum_{i=1}^{m}R\left(x_{i};\theta,b\right)\tilde{X}_{i,ip}\label{eq:GAL_obj}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $i$
\end_inset

 refers to the row numbers, and the residual function is defined as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_RES"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with the addition of the boundaries of the grid
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The coefficients 
\begin_inset Formula $\theta$
\end_inset

 depend on the bounds 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\end_inset

.
 We solve this system of 
\begin_inset Formula $p$
\end_inset

 equations with 
\family typewriter
fsolve
\family default
, and obtain the same solution as with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, because the residuals at the grid points will be zero when the system
 is exactly identified (
\begin_inset Formula $m=p$
\end_inset

).
\end_layout

\begin_layout Section
Spline methods
\end_layout

\begin_layout Standard
For the methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 we approximate the policy function with a spline.
 For this simple model we solve for the policy variable at the gridpoints
 
\begin_inset Formula $C_{i}=C\left(x_{i}\right)$
\end_inset

.
 These values are assigned to the vector 
\begin_inset Formula $POL.YY$
\end_inset

 by the toolbox.
 The objective is to set the residuals 
\begin_inset Formula $R$
\end_inset

 at each gridpoint 
\begin_inset Formula $i$
\end_inset

 to zero:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(x_{i};C_{i}\right) & =\left(\frac{C_{i}}{2e^{x_{i}}-C_{i}}\right)^{-\nu}-1\label{eq:SMPL_res_dir}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The policy function is defined by fitting a spline through these points
 for which we use 
\family typewriter
griddedInterpolant
\family default
.
 The spline is an interpolation method, which defines the policy function
 between grid points (or even outside the grid through extrapolation).
\end_layout

\begin_layout Standard
In general the objective function of spline methods is a square system with
 
\begin_inset Formula $m$
\end_inset

 equations and 
\begin_inset Formula $m$
\end_inset

 unknowns.
 With the Direct Computation method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 this system is solved with the nonlinear equation solver 
\family typewriter
fsolve
\family default
, which is based on Newton's method.
 The algorithm will numerically approximate the full 
\begin_inset Formula $m\times m$
\end_inset

  Jacobian.
 This makes the method especially inefficient for problems with a high number
 of gridpoints
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This simple example is non-recursive, such that the residual at each gridpoint
 is independent of the policy at other gridpoints.
 The Jacobian therefore only has entries on the diagonal.
 If we would supply this pattern of the Jacobian to 
\family typewriter
fsolve
\family default
 it would efficiently find a solution.
 However, for Direct Computation the solver 
\family typewriter
solve_proj 
\family default
does not apply any pattern as we in general solve recursive problems with
 the toolbox, for which the full Jacobian has to be computed.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The resulting policy function for the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 is plotted in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:DIR_proj}
\end_layout

\end_inset

.
 We used 4 equidistant nodes and a cubic spline.
 The maximum error in 
\begin_inset Formula $\hat{C}\left(x\right)$
\end_inset

 is 0.58 and is of similar magnitude as the polynomial solutions.
 The reason for this relatively large error is the small number of grid
 points.
 When we use Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) practically the same solution is obtained.
 The Time Iteration algorithm is especially useful for recursive problems,
 because it results in a sparse Jacobian as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Time-iteration"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Spline approximation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:DIR_proj}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ../../PROMES_v04.03/TEXT/FIGURES/dir.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Basic Procedure
\begin_inset CommandInset label
LatexCommand label
name "chap:The-Basics"

\end_inset


\end_layout

\begin_layout Standard
To set up, solve and evaluate a model with the 
\family typewriter
Promes
\family default
 toolbox one typically needs to take 6 steps:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Enumerate
Set the parameters and solve the steady state;
\end_layout

\begin_layout Enumerate
Set the parameters of the grid, and construct the grid using the function
 
\family typewriter
prep_grid
\family default
;
\end_layout

\begin_layout Enumerate
Create the model function, and function handle;
\end_layout

\begin_layout Enumerate
Make an initial guess for the policy function;
\end_layout

\begin_layout Enumerate
Solve the model, using the function 
\family typewriter
solve_proj;
\end_layout

\begin_layout Enumerate
Evaluate the solution using the function 
\family typewriter
get_pol_var
\family default
.
\end_layout

\begin_layout Standard
To explain the above steps we use a very simple deterministic macroeconomic
 model.
 We describe the model in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BM_model"
plural "false"
caps "false"
noprefix "false"

\end_inset

, define the approximated solution in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BM-Approx_solution"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and the program code in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BM_program"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The program is the function 
\family typewriter
main_det_bm_proj
\family default
, which can be found in the folder `PROMES_v04.3/Examples'.
 
\end_layout

\begin_layout Standard
The solution method 
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

 is the only input argument of the function 
\family typewriter
main_det_bm_proj
\family default
, and needs to be set to one of the five methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Deterministic Brock-Mirman model
\begin_inset CommandInset label
LatexCommand label
name "sec:BM_model"

\end_inset


\end_layout

\begin_layout Standard
The Brock-Mirman model that we use is a special case of the deterministic,
 representative agent growth problem described by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Example in 16.4 starting on page 549.
\end_layout

\end_inset

.
 The model is discussed in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Description-det-BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The deterministic version of the model has only one state variable, which
 is capital 
\begin_inset Formula $K_{t}$
\end_inset

.
 The advantage of this model is that there exists an analytical solution
 to which we can compare the numerical solution.
 
\end_layout

\begin_layout Standard
The representative agent maximizes his discounted utility:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max & \sum_{t=1}^{\infty}\beta^{t-1}\log\left(C_{t}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
subject to:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
K_{t+1}+C_{t} & =K_{t}^{\alpha}\label{eq:BM-budget}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C_{t}$
\end_inset

 is consumption in period 
\begin_inset Formula $t$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

 is the discount factor, 
\begin_inset Formula $K_{t}$
\end_inset

 is the capital stock 
\shape italic
at the beginning
\shape default
 of the period, and 
\begin_inset Formula $K_{t}^{\alpha}$
\end_inset

 is the production function.
 Applying the recursive formulation and taking the first order conditions
 with respect to 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

 we obtain the Euler equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{1}{C_{t}} & =\beta\frac{1}{C_{t+1}}\alpha K_{t+1}^{\alpha-1}\label{eq:Euler_BM}
\end{align}

\end_inset


\end_layout

\begin_layout Section
Approximation of the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:BM-Approx_solution"

\end_inset


\end_layout

\begin_layout Standard
The objective is to find the policy function for consumption as a function
 of the state variable capital.
 The two equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are sufficient to solve the model with projection methods.
 
\end_layout

\begin_layout Standard
We approximate the policy function for consumption (in logs) as a function
 of capital (in logs) 
\begin_inset Formula $c_{t}=c\left(k_{t}\right)$
\end_inset

, where we use smaller cases to denote a variable in logs, ie.
 
\begin_inset Formula $x_{t}=\log\left(X_{t}\right)$
\end_inset

.
 We approximate the policy function with either a polynomial or a spline
 
\begin_inset Formula $\hat{c}_{t}=\hat{c}\left(k_{t};\theta\right)$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

 for a more formal description.
\end_layout

\end_inset

, where 
\begin_inset Formula $\theta$
\end_inset

 is the vector of coefficients of the polynomial or spline, also called
 the parameterization.
 To indicate the parameterization of the 
\begin_inset Formula $j$
\end_inset

th iteration we write 
\begin_inset Formula $\theta^{j}$
\end_inset

.
 To obtain the solution we minimize the residuals of the Euler equation
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a finite number of gridpoints.
\end_layout

\begin_layout Standard
To calculate the Euler residuals at these gridpoints we first calculate
 next period's capital stock using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Using the simplified notation 
\begin_inset Formula $\hat{C}\left(K_{t};\theta\right)=\exp\left[\hat{c}\left(k_{t};\theta\right)\right]$
\end_inset

 we write:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{K}_{t+1} & =K_{t}^{\alpha}-\hat{C}\left(K_{t};\theta^{q}\right)\label{eq:BM_alm_k_pol}
\end{align}

\end_inset

 
\end_layout

\begin_layout Standard
\noindent
Next we substitute 
\begin_inset Formula $K_{t+1}$
\end_inset

 into the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
Finally we multiply both sides of the equation with 
\begin_inset Formula $\hat{C}\left(K_{t};\theta^{q}\right)$
\end_inset

 to normalize the Euler residuals.
 This scaling ensures that errors are more equally distributed.
 If we would not normalize the Euler residuals the errors in consumption
 would be larger for high levels of consumption, due to the risk aversion
 of the agent.
 The Euler residuals 
\begin_inset Formula $R$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(K_{t};\theta\right) & =\beta\frac{\hat{C}\left(K_{t};\theta^{q}\right)}{\hat{C}\left(\hat{K}_{t+1};\theta^{p}\right)}\alpha\hat{K}_{t+1}^{\alpha-1}-1\label{eq:BM_res_func}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Note that we use parameterization 
\begin_inset Formula $\theta^{q}$
\end_inset

 for period 
\begin_inset Formula $t$
\end_inset

 choices, and 
\begin_inset Formula $\theta^{p}$
\end_inset

 for next period's choice (ie.
 
\begin_inset Formula $\hat{C}_{t+1}=\hat{C}\left(\hat{K}_{t+1};\theta^{p}\right)$
\end_inset

).
 For all methods except Time Iteration these two parameterizations are the
 same, meaning 
\begin_inset Formula $\theta^{q}=\theta^{p}$
\end_inset

.
 With Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) 
\begin_inset Formula $\theta^{p}$
\end_inset

 refers to the parameterization of the previous iteration used for the choices
 in 
\begin_inset Formula $t+1$
\end_inset

, and 
\begin_inset Formula $\theta^{q}$
\end_inset

 to the parameterization in the current iteration used for choices in period
 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Section
Basic Procedure
\begin_inset CommandInset label
LatexCommand label
name "sec:BM_program"

\end_inset


\end_layout

\begin_layout Standard
To solve a model with the toolbox one needs to go through the 6 steps described
 above.
 In this section we describe these steps in the example code 
\family typewriter
main_det_bm_proj
\family default
 in the folder `PROMES_v04.3/Examples'.
 This file is a function, which includes all the subfunctions of the model.
 These subfunctions calculate the Euler residual (
\family typewriter
det_bm_res
\family default
), the steady state (
\family typewriter
det_bm_ss
\family default
) and auxiliary variables (
\family typewriter
det_bm_aux
\family default
)
\family typewriter
.

\family default
 Each of the 6 steps of the example program are described in the following
 Subsections.
 
\end_layout

\begin_layout Subsection*
Step 0: Matlab settings
\end_layout

\begin_layout Standard
Before running the example we set some general Matlab settings, and add
 the folder with the toolbox to the searchpath.
\end_layout

\begin_layout Subsection*
Step 1: Initial block
\end_layout

\begin_layout Standard
The initial block consists of two substeps, which are shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_step1}
\end_layout

\end_inset

.
 In Step 1.A we set the parameters of the model, and in Step 1.B we solve
 the steady state (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Description-det-BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the derivation of the steady state).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Step 1 \texttt{ main\_det\_bm\_proj}},label={pl:BM_step1}"
inline false
status open

\begin_layout Plain Layout

function main_det_bm_proj(sol_meth) 
\end_layout

\begin_layout Plain Layout

% Gets projection solution for deterministic version of  
\end_layout

\begin_layout Plain Layout

% Brock-Mirman model, using Promes toolbox
\end_layout

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

% INPUT: 
\end_layout

\begin_layout Plain Layout

% 		- sol_meth: solution method
\end_layout

\begin_layout Plain Layout

%		 ('mse','gal','tmi','dir' or 'mono')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% STEP 1: INITIAL BLOCK 
\end_layout

\begin_layout Plain Layout

% STEP 1.A: Set parameters of the model 
\end_layout

\begin_layout Plain Layout

par.alpha 	= 0.33;	% production: K^alpha 
\end_layout

\begin_layout Plain Layout

par.beta	= 0.96;	% discount factor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% STEP 1.B: Solve steady state 
\end_layout

\begin_layout Plain Layout

SS              = det_bm_ss(par);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 2: Construct the grid
\end_layout

\begin_layout Standard
The construction of the grid is shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_step2}
\end_layout

\end_inset

.
 In this step one needs to set the parameters of the grid, which is explained
 in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The first four parameters are set as fields in the structure 
\begin_inset Formula $GRID$
\end_inset

.
 These are the number of state variables 
\begin_inset Formula $n$
\end_inset

, the number of nodes 
\begin_inset Formula $q$
\end_inset

, and the lower bound and upper bound of the state variables, 
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

 respectively.
 When constructing the grid with 
\family typewriter
prep_grid
\family default
 one also needs to set the solution method 
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

, because the type of grid that is constructed depends on this solution
 method.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Step 2 \texttt{ main\_det\_bm\_proj}},label={pl:BM_step2}"
inline false
status open

\begin_layout Plain Layout

%% STEP 2: Construct the grid 
\end_layout

\begin_layout Plain Layout

% STEP 2.A: Set parameters & bounds of grid, in log(K) 
\end_layout

\begin_layout Plain Layout

GRID.nn 		= 1;% number of state variables 
\end_layout

\begin_layout Plain Layout

GRID.qq 		= 25;% number of gridpoints 
\end_layout

\begin_layout Plain Layout

% Boundaries of grid at steady state +/- 20%:
\end_layout

\begin_layout Plain Layout

GRID.lb(1)	= -0.2 + log(SS.Kss);% lower bound 
\end_layout

\begin_layout Plain Layout

GRID.ub(1)	= 0.2 + log(SS.Kss);% upper bound
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% STEP 2.B: Assign solution method to POL: 
\end_layout

\begin_layout Plain Layout

% ('mse','gal','tmi','dir' or 'mono'): 
\end_layout

\begin_layout Plain Layout

POL.sol_meth    = sol_meth;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% STEP 2.C: Construct the grid 
\end_layout

\begin_layout Plain Layout

% using default order for polynomials
\end_layout

\begin_layout Plain Layout

GRID 	= prep_grid(GRID.nn,GRID.qq,GRID.lb,GRID.ub,POL.sol_meth); 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
prep_grid
\family default
 will assign all the necessary properties to the structure 
\begin_inset Formula $GRID$
\end_inset

, given the solution method.
 The 
\begin_inset Formula $GRID$
\end_inset

 includes the initial grid 
\begin_inset Formula $xx$
\end_inset

, which is a 
\begin_inset Formula $m$
\end_inset

 x 
\begin_inset Formula $n$
\end_inset

 matrix, where every column is a state vector, and every row a unique gridpoint.
 The explanation of the grid structure is found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with an example in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It should be emphasized that the structure 
\begin_inset Formula $GRID$
\end_inset

 is constructed for a specific solution type, either a spline, Chebyshev
 polynomial, or a regular polynomial.
 
\end_layout

\begin_layout Subsection*
Step 3: Model function
\end_layout

\begin_layout Standard
The model function should calculate the Euler residuals, given the initial
 grid and the policy function.
 The model for this example is shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

.
 The file takes the structure with parameters 
\begin_inset Formula $par$
\end_inset

, the structure 
\begin_inset Formula $GRID$
\end_inset

, and the structure 
\begin_inset Formula $POL$
\end_inset

 as input arguments.
 The modeler needs to include an initial guess for the policy function in
 Step 4.
 The function solver 
\family typewriter
solve_proj
\family default
 will assign the appropriate policy function (spline or polynomial) to the
 structure 
\begin_inset Formula $POL$
\end_inset

.
 More details on constructing a model file are given in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
First the model retrieves the state variable capital in logs 
\begin_inset Formula $k_{t}$
\end_inset

, which is 
\begin_inset Formula $LK$
\end_inset

 in the code.
 Since there is only one state variable, it is the first and only column
 of the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

, as shown in Line 5.
 Next we have to evaluate the policy function given the state variable:
 
\begin_inset Formula $\hat{c}_{t}=c\left(k_{t};\theta\right)$
\end_inset

.
 For all methods except 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 the policy function is evaluated by calling the function 
\family typewriter
get_pol_var
\family default
 as shown in Line 10 of Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

.
 This call takes the policy function 
\begin_inset Formula $POL$
\end_inset

, the state variable in period 
\begin_inset Formula $t$
\end_inset

 (
\begin_inset Formula $LK$
\end_inset

) and the structure 
\begin_inset Formula $GRID$
\end_inset

 as inputs.
 For the method
\family typewriter
 
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 the solver directly sets the policy function 
\begin_inset Formula $c_{t}^{i}$
\end_inset

 at all gridpoints 
\begin_inset Formula $i$
\end_inset

.
 These values are assigned to 
\begin_inset Formula $POL.YY$
\end_inset

 as shown in Line 15.
\end_layout

\begin_layout Standard
Next we calculate 
\begin_inset Formula $k_{t+1}$
\end_inset

, given 
\begin_inset Formula $k_{t}$
\end_inset

 and 
\begin_inset Formula $\hat{c}_{t}$
\end_inset

 as in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_alm_k_pol"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Line 19), and finally we need to calculate 
\begin_inset Formula $\hat{c}_{t+1}=c\left(k_{t+1};\theta\right)$
\end_inset

.
 For all methods except 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 we simply evaluate the policy function using the function 
\family typewriter
get_pol_var
\family default
 with 
\begin_inset Formula $k_{t+1}$
\end_inset

 as input argument (Line 23).
 For the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 we need to use the policy function of the old iteration 
\begin_inset Formula $\theta^{p}$
\end_inset

.
 To ensure the old policy function is used for next period's choices set
 
\begin_inset Formula $spec\textrm{\_}opt=2$
\end_inset

 (Line 28).
 With 
\begin_inset Formula $c_{t}$
\end_inset

, 
\begin_inset Formula $\hat{c}_{t+1}$
\end_inset

 and 
\begin_inset Formula $k_{t+1}$
\end_inset

 known we can calculate the vector of Euler residuals as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_res_func"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Lines 32, 35, and 38).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Model function \texttt{main\_det\_bm\_proj}},label={pl:BM_mod}"
inline false
status open

\begin_layout Plain Layout

%% Deterministic B-M model file, or residual function: 
\end_layout

\begin_layout Plain Layout

function [RES] = det_bm_res(par,GRID,POL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Initial grid is stored in GRID.xx: 
\end_layout

\begin_layout Plain Layout

LK = GRID.xx;%log(K_t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Evaluate the policy function log(C):
\end_layout

\begin_layout Plain Layout

if ~strcmp(POL.sol_meth,'tmi')     
\end_layout

\begin_layout Plain Layout

  % standard: log(C) from policy function     
\end_layout

\begin_layout Plain Layout

  LC = get_pol_var(POL,LK,GRID); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

  %tmi: solver directly sets log(C) 
\end_layout

\begin_layout Plain Layout

  % at grid points 
\end_layout

\begin_layout Plain Layout

  LC = POL.YY; 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Capital in next period (log):  
\end_layout

\begin_layout Plain Layout

LK_n = log( exp(par.alpha*LK) - exp(LC) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% log(C_t+1) from policy function, given log(K_t+1):  
\end_layout

\begin_layout Plain Layout

if ~strcmp(POL.sol_meth,'tmi')
\end_layout

\begin_layout Plain Layout

  LC_n = get_pol_var(POL,LK_n,GRID);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

else% for 'tmi':     	
\end_layout

\begin_layout Plain Layout

  % use old policy function pp_y_old  (theta_p)    	
\end_layout

\begin_layout Plain Layout

  spec_opt_next = 2;  	
\end_layout

\begin_layout Plain Layout

  LC_n = get_pol_var(POL,LK_n,GRID,[],spec_opt_next);  
\end_layout

\begin_layout Plain Layout

end 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% log(RR_t+1): marginal prod.
 of capital (logs) 
\end_layout

\begin_layout Plain Layout

LR_n = log(par.alpha) + (par.alpha-1)*LK_n;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% RHS of Euler equation: 
\end_layout

\begin_layout Plain Layout

RHS         = par.beta * exp(-LC_n) .* exp(LR_n);     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Euler residual (scaled by C^-1):
\end_layout

\begin_layout Plain Layout

RES         = exp(LC).*RHS - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, we need to create a function handle to the model function, which
 takes the structure 
\begin_inset Formula $POL$
\end_inset

 as input argument:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Create function handle},label={pl:BM_step3}"
inline false
status open

\begin_layout Plain Layout

%% STEP 3: Handle for objective function  
\end_layout

\begin_layout Plain Layout

% (ie.
 the model file)  
\end_layout

\begin_layout Plain Layout

fun_res     = @(POL)det_bm_res(par,GRID,POL);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This function handle is used as input for the solver 
\family typewriter
solve_proj
\family default
, and will assign the policy function to the structure 
\begin_inset Formula $POL$
\end_inset

 when it solves the model.
\end_layout

\begin_layout Subsection*
Step 4: Initial guess
\end_layout

\begin_layout Standard
The initial guess 
\begin_inset Formula $Y0$
\end_inset

 for the policy function should give the value of the policy variable at
 the initial grid.
 This initial guess is an input argument for the solver 
\family typewriter
solve_proj
\family default
.
 For this simple model all methods will converge to the correct solution
 from a relatively poor initial guess.
 As the initial guess we add a small linear term of the state variable capital
 to the steady state value of consumption:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 4: Initial guess policy function of log(c) 
\end_layout

\begin_layout Plain Layout

% steady state consumption +  small linear term in [log(K)-log(Kss)]:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Y0      = log(SS.Css) + 0.01*(GRID.xx-log(SS.Kss));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
For more complex models one could use the perturbation solution as initial
 guess.
 Some more general hints for the initial guess are given in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-4:-Initial"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection*
Step 5: Solve the model
\end_layout

\begin_layout Standard
To solve the model the function 
\family typewriter
solve_proj
\family default
 is called.
 It takes as inputs the structure 
\begin_inset Formula $GRID$
\end_inset

, the structure 
\begin_inset Formula $POL$
\end_inset

, the function handle to the residual function 
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

, and the initial guess 
\begin_inset Formula $Y0$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%%% STEP 5: Solve the model 
\end_layout

\begin_layout Plain Layout

POL         = solve_proj(GRID,POL,fun_res,Y0); 
\end_layout

\begin_layout Plain Layout

clear Y0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The structure 
\begin_inset Formula $POL$
\end_inset

 at this points only needs to contains the solution method.
 The function 
\family typewriter
solve_proj
\family default
 will assign the appropriate policy function (spline or polynomial) to the
 structure 
\begin_inset Formula $POL$
\end_inset

.
 For the methods that use polynomials (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

) this will be a coefficient matrix in the field 
\begin_inset Formula $POL.theta$
\end_inset

.
 For the methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 the policy function is a spline, in the cell array 
\begin_inset Formula $POL.pp\textrm{\_}y$
\end_inset

.
 The spline 
\begin_inset Formula $pp\textrm{\_}y$
\end_inset

 is constructed with Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 
\end_layout

\begin_layout Subsection*
Step 6: Evaluate the solution
\end_layout

\begin_layout Standard
To evaluate the solution a call to the function 
\family typewriter
get_pol_var
\family default
 with inputs 
\begin_inset Formula $POL$
\end_inset

, the state variables, and the structure 
\begin_inset Formula $GRID$
\end_inset

 suffices.
 In the example file we evaluate the policy at the initial grid:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 6: Evaluate policy function: 
\end_layout

\begin_layout Plain Layout

LK = GRID.xx; % = initial grid 
\end_layout

\begin_layout Plain Layout

LC = get_pol_var(POL,LK,GRID);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-6:-Evaluating"
plural "false"
caps "false"
noprefix "false"

\end_inset

 it is shown how to evaluate the policy variable in a simulation.
\end_layout

\begin_layout Standard
In our example we also plot the policy function.
 In addition we plot the difference between the numerical solution 
\begin_inset Formula $\hat{c}\left(k_{t};\theta\right)$
\end_inset

 and analytical solution 
\begin_inset Formula $c\left(k_{t}\right)$
\end_inset

, which shows that the maximum absolute errors are very small, and are between
 1e-9 and 1e-13.
 Since the analytical solution is linear in log capital, the policy can
 be approximated up to double precision by splines and polynomials.
 This means the errors can theoretically be reduced to the double precision,
 which is of the order 1e-16.
 
\end_layout

\begin_layout Chapter
Detailed Procedure
\begin_inset CommandInset label
LatexCommand label
name "chap:RBC-example"

\end_inset


\end_layout

\begin_layout Standard
In this Chapter we discuss the procedure to solve a model in more detail.
 We use the example of a standard RBC model with stochastic shocks in Total
 Factor Productivity, which we call the Standard RBC example.
 We first briefly describe the model in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:RBC_Model"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The main program file is 
\family typewriter
main_stnd_rbc_proj
\family default
 in the folder `PROMES_v04.3/Examples'.
 That script solves the model, and simulates time series.
 Each step in the process is described in more detail in Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-1:-Initialization"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-6:-Evaluating"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Standard RBC model
\begin_inset CommandInset label
LatexCommand label
name "sec:RBC_Model"

\end_inset


\end_layout

\begin_layout Standard
The model consists of two state variables, capital 
\begin_inset Formula $K_{t}$
\end_inset

 and Total Factor Productivity (TFP) 
\begin_inset Formula $Z_{t}$
\end_inset

.
 Capital is determined endogenously, while TFP follows a stochastic process.
 We choose consumption 
\begin_inset Formula $C_{t}$
\end_inset

 as policy variable, which we approximate as a function of the state variables.
 The model is captured by four equations (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Standard_RBC_model"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1} & =Z_{t}K_{t}^{\alpha}H_{t}^{1-\alpha}+\left(1-\delta\right)K_{t}\label{eq:ALM_k}\\
\chi H_{t}^{\frac{1}{\eta}} & =C_{t}^{-\nu}Z_{t}\left(1-\alpha\right)K_{t}^{\alpha}H_{t}^{-\alpha}\label{eq:lab_sup}\\
C_{t}^{-\nu} & =\beta E_{t}\left\{ C_{t+1}^{-\nu}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}H_{t+1}^{1-\alpha}+1-\delta\right]\right\} \label{eq:Euler_res}\\
z_{t} & =\rho_{z}z_{t-1}+\sigma_{z}\epsilon_{t}\label{eq:TFP}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where smaller cases indicate logs, ie.
 
\begin_inset Formula $z_{t}=\log\left(Z_{t}\right)$
\end_inset

.
 The autocorrelation coefficient is 
\begin_inset Formula $\rho_{z}$
\end_inset

 , and the standard deviation of the shocks 
\begin_inset Formula $\sigma_{z}$
\end_inset

.
 The shocks are standard normally distributed, ie.
 
\begin_inset Formula $\epsilon_{t}\sim\mathcal{N}\left(0,1\right)$
\end_inset

.
\end_layout

\begin_layout Section
Step 0: Matlab Settings
\end_layout

\begin_layout Standard
The only function of Step 0 is to prepare Matlab for running the script.
 It includes clearing all variables in the workspace, and adding folders
 to the searchpath.
\end_layout

\begin_layout Subsubsection*
Clearing and set breakpoint
\end_layout

\begin_layout Standard
When using a script you typically want to clear all variables from the workspace
 using 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{clearvars}
\end_layout

\end_inset

, which is not needed if a function is used.
 In the initial block of our program we close all figures (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{close all}
\end_layout

\end_inset

), clear the command prompt (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{clc}
\end_layout

\end_inset

), and ensure that we can access all local variables at the time an error
 occurs by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{dbstop if error}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Adding folders
\end_layout

\begin_layout Standard
Next, we need to add the folders `PROMES_v04.3', and `TOOLS' and their subfolders
 to the searchpath.
 The folder `PROMES_v04.3' contains the main functions of the 
\family typewriter
Promes
\family default
 toolbox.
 We need the folder `TOOLS' for the calculation of the Gauss-Hermite nodes
 with the function
\family typewriter
 hernodes
\family default
, and to obtain the perturbation solution with the 
\family typewriter
CSD
\family default
 toolbox in the subfolder `CSD_v0X.X'.
\end_layout

\begin_layout Standard
Our model specific files are stored in the folder `PROMES_v04.3
\backslash
Examples
\backslash
STND_RBC_mod'.
 These files include the model file 
\family typewriter
STND_RBC_proj
\family default
.
 The other subfunctions of this model are 
\family typewriter
stnd_rbc_ss
\family default
 which calculates the steady state, 
\family typewriter
stnd_rbc_aux
\family default
 which calculates auxiliary variables of the model, and 
\family typewriter
stnd_rbc_sim
\family default
 which is used to run simulations.
 In addition there is the function 
\family typewriter
plot_pol_stnd_rbc
\family default
 which is used to plot the policy functions.
 In our main program file 
\family typewriter
main_stnd_rbc_proj
\family default
 Step 0 is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% Solves standard RBC model with projection 
\end_layout

\begin_layout Plain Layout

% for a single variable policy function 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% STEP 0: Matlab settings
\end_layout

\begin_layout Plain Layout

clearvars; 
\end_layout

\begin_layout Plain Layout

close all; %close all figures 
\end_layout

\begin_layout Plain Layout

clc; %clear command prompt 
\end_layout

\begin_layout Plain Layout

dbstop if error;%acces workspace if error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

restoredefaultpath; 
\end_layout

\begin_layout Plain Layout

clear RESTOREDEFAULTPATH_EXECUTED;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Add one folder up: folder with Promes toolkit 
\end_layout

\begin_layout Plain Layout

% (genpath includes all subfolders) 
\end_layout

\begin_layout Plain Layout

addpath (genpath('..'));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Add folder TOOLS 
\end_layout

\begin_layout Plain Layout

addpath (genpath('..
\backslash
..
\backslash
TOOLS'));
\end_layout

\end_inset


\end_layout

\begin_layout Section
Step 1: Initial Block
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-1:-Initialization"

\end_inset


\end_layout

\begin_layout Standard
The Initial Block consists of two parts:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}[label=
\backslash
Alph*.] 
\end_layout

\begin_layout Plain Layout


\backslash
item Set parameters
\end_layout

\begin_layout Plain Layout


\backslash
item Solve steady state
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In our function 
\family typewriter
main_stnd_rbc_proj
\family default
 we store all parameters in a structure called 
\begin_inset Formula $par$
\end_inset

.
 The steady state values are stored in a structure 
\begin_inset Formula $SS$
\end_inset

.
 The structure 
\begin_inset Formula $SS$
\end_inset

 is used for the determination of the lower and upper bound of the capital
 stock, the initialization of the policy function and the function that
 plots the policy functions.
\end_layout

\begin_layout Subsection*
Step 1.A: Set parameters
\end_layout

\begin_layout Standard
We assign all the parameters of the model to the structure 
\begin_inset Formula $par$
\end_inset

, so we only have to pass this structure to a function to access all parameters
 of the model.
 In our example we will use Gauss-Hermite quadrature 
\begin_inset CommandInset citation
LatexCommand citep
before "see the chapter on Numerical Integration in"
key "judd1998numerical"
literal "false"

\end_inset

, so we also add the Gauss-Hermite nodes (
\begin_inset Formula $par.her.xi$
\end_inset

) and its weights (
\begin_inset Formula $par.her.wi$
\end_inset

) to the parameters.
\end_layout

\begin_layout Standard
In our example script 
\family typewriter
main_stnd_rbc_proj
\family default
 Step 1.A is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% STEP 1.A: Set parameters of the model 
\end_layout

\begin_layout Plain Layout

par.alpha       = 0.36;		%capital share income  
\end_layout

\begin_layout Plain Layout

par.beta        = 0.985;	% discount factor 
\end_layout

\begin_layout Plain Layout

par.delta       = 0.025;	% deprec.
 of capital  
\end_layout

\begin_layout Plain Layout

par.nu          = 2; 		% risk aversion  
\end_layout

\begin_layout Plain Layout

par.eta         = 4; 		% el.
 of lab.
 supply 
\end_layout

\begin_layout Plain Layout

par.chi         = 1; 		% scalar disut.
 work
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

par.rho_z       = 0.95;	% autocorr.
 coeff.
 TFP 
\end_layout

\begin_layout Plain Layout

par.sigma_z     = 0.01;	% standard dev.
 shocks in TFP 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

par.her.gh_nod  = 5;% number of Gauss-Hermite nodes 
\end_layout

\begin_layout Plain Layout

[par.her.xi,par.her.wi] = hernodes(par.her.gh_nod); 
\end_layout

\begin_layout Plain Layout

% xi are roots, wi are weights
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 1.B: Solve steady state
\end_layout

\begin_layout Standard
We usually want a good approximation of the policy function for a particular
 interval of the state variables, which is usually centered around the steady
 state.
 To construct an appropriate grid we therefore typically calculate the steady
 state.
 For our Standard RBC example we created the function 
\family typewriter
stnd_rbc_ss
\family default
 that calculates the steady state analytically (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:RBC_steady-state"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This function takes the parameters and the steady state Total Factor Productivi
ty (
\begin_inset Formula $Z_{ss}=1$
\end_inset

) as inputs.
 In the script 
\family typewriter
main_stnd_rbc_proj 
\family default
our call to the steady state function is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 1.B: Solve steady state 
\end_layout

\begin_layout Plain Layout

SS              = stnd_rbc_ss(par,1);
\end_layout

\begin_layout Plain Layout

% the 1 is steady state TFP 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Step 2: Construct the grid
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-2:-Grid"

\end_inset


\end_layout

\begin_layout Standard
The construction of the grid is done using the following substeps:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}[label=
\backslash
Alph*.] 
\end_layout

\begin_layout Plain Layout


\backslash
item Set grid parameters 
\end_layout

\begin_layout Plain Layout


\backslash
item Set solution method
\end_layout

\begin_layout Plain Layout


\backslash
item Construct grid
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The grid parameters, and also the grid itself will be stored in the structure
 
\begin_inset Formula $GRID$
\end_inset

.
 This needs to be initialized with a couple of parameters in Step 2.A.
 The solution type has to be assigned to the structure 
\begin_inset Formula $POL$
\end_inset

 in Step 2.B, before constructing the grid.
 
\end_layout

\begin_layout Standard
The necessary fields of the structure 
\begin_inset Formula $GRID$
\end_inset

 and the solution method are then fed into the function 
\family typewriter
prep_grid
\family default
 (Step 2.C).
 This function replaces the structure 
\begin_inset Formula $GRID$
\end_inset

, and assigns all the fields required for the selected solution method.
 More details on how the grid is constructed can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 That chapter also includes an example code, 
\family typewriter
grid_example
\family default
, that demonstrates the construction of a grid.
\end_layout

\begin_layout Subsection*
Step 2.A: Set grid parameters
\end_layout

\begin_layout Standard
The 
\family typewriter
prep_grid
\family default
 function needs the following inputs: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: number of variables in the grid (scalar);
\end_layout

\begin_layout Itemize
\begin_inset Formula $qq$
\end_inset

: vector of number of nodes in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

: the solution method, which is either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, and is discussed in Step 2.B.
\end_layout

\begin_layout Standard
These properties are necessary to create the structure 
\begin_inset Formula $GRID$
\end_inset

.
 In our model we have two state variables, capital (
\begin_inset Formula $K$
\end_inset

) and Total Factor Productivity (
\begin_inset Formula $Z$
\end_inset

).
 For the construction of the grid we use the logarithm of both variables.
 We set the number of nodes to 11 in each dimension.
 We set the lower and upper bound for each state variable symmetrically
 around this steady state.
 For capital we use a factor 0.2, and for Total Factor Productivity we use
 3 standard deviations, which is standard 
\begin_inset CommandInset citation
LatexCommand citep
before "see for example"
key "guerrieri2015occbin"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 2: Construct the grid 
\end_layout

\begin_layout Plain Layout

%Step 2.A: Initialize the grid  
\end_layout

\begin_layout Plain Layout

GRID.nn      = 2;%number of state variables (K,Z)
\end_layout

\begin_layout Plain Layout

GRID.qq      = [11,11];%number of nodes per dimension
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Set lower and upper bound for capital: 
\end_layout

\begin_layout Plain Layout

GRID.lk_dev  = 0.2;% 20% deviation from kss 
\end_layout

\begin_layout Plain Layout

GRID.lb(1)   = -GRID.lk_dev + log(SS.kss);  
\end_layout

\begin_layout Plain Layout

GRID.ub(1)   =  GRID.lk_dev + log(SS.kss);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Set lower and upper bound for log(z)  
\end_layout

\begin_layout Plain Layout

% standard is 3 x stnd.
 deviations  
\end_layout

\begin_layout Plain Layout

% (see Guerriei & Iacoviello, 2015, JME)  
\end_layout

\begin_layout Plain Layout

GRID.lz_fac  = 3;  
\end_layout

\begin_layout Plain Layout

GRID.lb(2)   = -GRID.lz_fac*...
\end_layout

\begin_layout Plain Layout

	sqrt( par.sigma_z^2 / (1-par.rho_z^2) );  
\end_layout

\begin_layout Plain Layout

GRID.ub(2)   =  GRID.lz_fac*...
\end_layout

\begin_layout Plain Layout

	sqrt( par.sigma_z^2 / (1-par.rho_z^2) );
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 2.B: Set solution method
\begin_inset CommandInset label
LatexCommand label
name "subsec:Step-2B-Sol_meth"

\end_inset


\end_layout

\begin_layout Standard
The solution method 
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

 is set as a field in the structure 
\begin_inset Formula $POL$
\end_inset

.
 There are five choices, which are discussed in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 In general we recommend either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 as discussed in more detail in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-'solve_proj'"
plural "false"
caps "false"
noprefix "false"

\end_inset

 under Solution Methods.
 
\end_layout

\begin_layout Standard
The methods using splines are a good choice if one expects the shape of
 the policy is to be poorly approximated with a polynomial.
 Of the spline methods Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

) works well for a low number of gridpoints.
 Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) is especially useful if convergence is an issue.
 
\end_layout

\begin_layout Standard
The five options are:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

: Minimization of Squared Errors, which uses a complete Chebyshev polynomial
 of specified order (for 
\begin_inset Formula $order$
\end_inset

 see below);
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

: Galerkin projection method, which uses a complete Chebyshev polynomial
 of specified order (for 
\begin_inset Formula $order$
\end_inset

 see below).
 The objective of this solution method is that the residuals are orthogonal
 to the Chebyshev polynomial terms;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

: Time Iteration, which uses a spline to approximate the policy function.
 The objective is to set the residuals at each gridpoint to zero.
 The spline is defined by Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 The interpolation method can be specified in the field 
\begin_inset Formula $POL.meth\textrm{\_}spl$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

: Direct Computation where the policy function is a spline.
 The objective is to set the Euler residuals at each gridpoint to zero.
 The spline is defined by Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 The interpolation method can be specified in the field 
\begin_inset Formula $POL.meth\textrm{\_}spl$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

: Monomial basis functions of specified order (for 
\begin_inset Formula $order$
\end_inset

 see below) are used to approximate the policy function by minimization
 of the squared errors (Euler residuals).
 This method is not recommended, since it is inaccurate and is only included
 for illustration purposes.
\end_layout

\begin_layout Standard
For the solution types 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 we can optionally specify the order of the polynomial.
 This is done by setting the optional input argument of the function 
\family typewriter
prep_grid:
\end_layout

\begin_layout Itemize
\begin_inset Formula $order$
\end_inset

 (optional): the order of the polynomial (scalar).
 If the 
\begin_inset Formula $order$
\end_inset

 is not specified the default for solution types 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 is 
\begin_inset Formula $GRID.order=5$
\end_inset

, and for solution type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 the default is 
\begin_inset Formula $GRID.order=3$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Example Standard RBC model
\end_layout

\begin_layout Standard
In our example we set 
\begin_inset Formula $POL.sol\textrm{\_}meth$
\end_inset

 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, but this can be set to any of the other methods.
 In our example 
\family typewriter
main_stnd_rbc_proj
\family default
 the code of Step 2.B is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% STEP 2.B: Set solution type: 'mse','gal','tmi','dir', or 'mono' 
\end_layout

\begin_layout Plain Layout

POL.sol_meth    = 'mse';
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 2.C: Construct the grid
\end_layout

\begin_layout Standard
The construction of the grid is carried out by the function 
\family typewriter
prep_grid
\family default
, which needs the five inputs discussed in Step 2.A.
 This function and all its subfunctions are explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We assigned the necessary fields to the structures 
\begin_inset Formula $GRID$
\end_inset

 and 
\begin_inset Formula $POL$
\end_inset

, so we refer to them when calling 
\family typewriter
prep_grid
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% STEP 2.C: Construct the grid 
\end_layout

\begin_layout Plain Layout

% use default order for polynomials 
\end_layout

\begin_layout Plain Layout

% (order 3 for 'mono', order 5 for 'mse'/'gal')
\end_layout

\begin_layout Plain Layout

GRID            = prep_grid(GRID.nn,GRID.qq,GRID.lb,GRID.ub,POL.sol_meth);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
prep_grid
\family default
 will assign all the necessary fields to the structure 
\begin_inset Formula $GRID$
\end_inset

.
 The most important of these is the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

, which is an 
\begin_inset Formula $m$
\end_inset

 x 
\begin_inset Formula $n$
\end_inset

 matrix, where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints, and 
\begin_inset Formula $n$
\end_inset

 the number of state variables.
 Each row is a unique gridpoint, and every column represents a state variable.
 The first column 
\begin_inset Formula $GRID.xx\left(:,1\right)$
\end_inset

 contains capital in logs, and the second 
\begin_inset Formula $GRID.xx\left(:,2\right)$
\end_inset

 Total Factor productivity in logs.
 
\end_layout

\begin_layout Standard
It should be noted that the grid structure is specific to the approximation
 type, which is either a spline, a Chebyshev polynomial or a regular polynomial.
 If one changes the solution type a new grid structure should be constructed
 with 
\family typewriter
prep_grid
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 use the same grid as do 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Step 3: Model function and handle
\begin_inset CommandInset label
LatexCommand label
name "sec:Model_file"

\end_inset


\end_layout

\begin_layout Standard
Step 3 consists of two parts:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}[label=
\backslash
Alph*.] 
\end_layout

\begin_layout Plain Layout


\backslash
item Program model function
\end_layout

\begin_layout Plain Layout


\backslash
item Create handle to model function
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The creation of the model function is the most crucial part when using this
 toolbox.
 The model function should return a column vector with residuals as output.
 To solve the model with the solver 
\family typewriter
solve_proj
\family default
 a function handle of this model function has to be created.
 This function handle should take the structure 
\begin_inset Formula $POL$
\end_inset

 as input.
\end_layout

\begin_layout Subsection*
Step 3A: Program model function
\end_layout

\begin_layout Standard
The model function, which has to be programmed by the modeler, should calculate
 the Euler residuals at each gridpoint, given the policy function.
 The model file should at least take the grid structure 
\begin_inset Formula $GRID$
\end_inset

, and the structure with the policy 
\begin_inset Formula $POL$
\end_inset

 as inputs.
 Other inputs are also allowed.
 In our example we also use the structure with the parameters 
\begin_inset Formula $par$
\end_inset

 as input.
 
\end_layout

\begin_layout Standard
For the Standard RBC model the model function is 
\family typewriter
STND_RBC_proj
\family default
, which is shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

.
 The function calculates the residuals of the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as output, for a given policy function and initial grid.
 Note that we scale the residuals by 
\begin_inset Formula $C^{-\nu}$
\end_inset

 as explained below.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Model function \texttt{STND\_RBC\_proj}},label={pl:RBC_mod}"
inline false
status open

\begin_layout Plain Layout

function [RES] = STND_RBC_proj(par,GRID,POL) 
\end_layout

\begin_layout Plain Layout

% Calculates Euler residuals for standard RBC model
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

LK = GRID.xx(:,1);%first state variable, log(K_t) 
\end_layout

\begin_layout Plain Layout

LZ = GRID.xx(:,2);%second state variable, log(Z_t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%policy variable, log(C_t): 
\end_layout

\begin_layout Plain Layout

if ~strcmp(POL.sol_type,'tmi') %standard format    
\end_layout

\begin_layout Plain Layout

  %use initial grid for 'gal', 'mse', 'mono':   	
\end_layout

\begin_layout Plain Layout

  spec_opt = 1;         
\end_layout

\begin_layout Plain Layout

  LC = get_pol_var(POL,[LK,LZ],GRID,[],spec_opt); 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

else%for 'tmi':     
\end_layout

\begin_layout Plain Layout

  LC  = POL.YY;%LC is set directly  
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Capital in next period: 
\end_layout

\begin_layout Plain Layout

LK_n    = stnd_rbc_aux(par,LK,LZ,LC);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if strcmp(POL.sol_type,'tmi')     
\end_layout

\begin_layout Plain Layout

  % use the old policy function pp_y_old     
\end_layout

\begin_layout Plain Layout

  spec_opt_next = 2; 
\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

  spec_opt_next = []; 
\end_layout

\begin_layout Plain Layout

end         
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Allocate empty matrix for RHS of Euler equation: 
\end_layout

\begin_layout Plain Layout

rhs_j   = NaN(size(LK,1),par.her.gh_nod); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for jj = 1:par.her.gh_nod     
\end_layout

\begin_layout Plain Layout

  % Shock to TFP (using Gauss-Hermite nodes):     
\end_layout

\begin_layout Plain Layout

  EPS_n       = sqrt(2)*par.her.xi(jj); 
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

  %log(Z_t+1):     
\end_layout

\begin_layout Plain Layout

  LZ_n        = par.rho_z*LZ + par.sigma_z*EPS_n;          
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  %log(C_t+1)     
\end_layout

\begin_layout Plain Layout

  LC_n        = get_pol_var(POL,[LK_n,LZ_n],GRID,[],spec_opt_next);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  %log(MPK_t+1) (marginal prod.
 of capital)     
\end_layout

\begin_layout Plain Layout

  [~,LMPK_n]    = stnd_rbc_aux(par,LK_n,LZ_n,LC_n);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  % RHS of Euler equation,      
\end_layout

\begin_layout Plain Layout

  % weighted by Gauss-Hermite weights     
\end_layout

\begin_layout Plain Layout

  rhs_j(:,jj) = par.her.wi(jj)/sqrt(pi)*par.beta*...
\end_layout

\begin_layout Plain Layout

	exp(-par.nu*LC_n) .* ...
\end_layout

\begin_layout Plain Layout

	(exp(LMPK_n)+1 - par.delta); 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Right hand side of Euler equation: 
\end_layout

\begin_layout Plain Layout

RHS = sum(rhs_j,2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Euler residuals (scaled by C^-nu): 
\end_layout

\begin_layout Plain Layout

RES     =  RHS./exp(-par.nu *LC) - 1;    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Evaluating the policy function 
\end_layout

\begin_layout Standard
First we calculate the policy variable at the initial grid for a given policy
 function 
\begin_inset Formula $C\left(K_{t},Z_{t};\theta\right)$
\end_inset

.
 The initial state is stored in the matrix 
\begin_inset Formula $GRID.xx$
\end_inset

, where the column vectors are capital and productivity (in logs) as shown
 in Line 4 and 5.
 To evaluate the policy function we differentiate between Time Iteration
 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) and the other methods (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details).
 For the methods based on polynomials we save computation time by evaluating
 the policy function at the initial grid in period 
\begin_inset Formula $t$
\end_inset

 by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt = 1}
\end_layout

\end_inset

 (Line 10).
 This option is ignored with Direction Computation.
 With Time Iteration the algorithm directly sets the current period's policy
 variable at the gridpoints (
\begin_inset Formula $\hat{c}_{t}^{i}$
\end_inset

 for gridpoint 
\begin_inset Formula $i$
\end_inset

).
 These values are stored in 
\begin_inset Formula $POL.YY$
\end_inset

 by the algorithm, and are called directly in the model file (Line 14).
\end_layout

\begin_layout Standard
For next period's choices we also differentiate between Time Iteration and
 the other methods.
 For the other methods we call 
\family typewriter
get_pol_var
\family default
, using the default option to evaluate the policy function with 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $Z_{t+1}$
\end_inset

 as inputs.
 For Time Iteration we need to use the policy function of the previous iteration
, which we achieve by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt_next = 2}
\end_layout

\end_inset

 when calling 
\family typewriter
get_pol_var
\family default
, as shown in Line 22 and 38.
\end_layout

\begin_layout Subsubsection*
Auxiliary variables
\end_layout

\begin_layout Standard
In the model function we need to calculate the capital stock in the next
 period 
\begin_inset Formula $K_{t+1}$
\end_inset

, and the marginal productivity of capital 
\begin_inset Formula $MPK_{t}=\alpha K_{t}^{\alpha-1}H_{t}^{1-\alpha}$
\end_inset

, for a given state 
\begin_inset Formula $\left[K_{t},Z_{t}\right]$
\end_inset

 and consumption 
\begin_inset Formula $C_{t}$
\end_inset

.
 
\end_layout

\begin_layout Standard
To obtain these variables we calculate the labor supply.
 The labor supply 
\begin_inset Formula $H$
\end_inset

 is an explicit function of the state variables 
\begin_inset Formula $Z$
\end_inset

 and 
\begin_inset Formula $K$
\end_inset

, and consumption 
\begin_inset Formula $C$
\end_inset

:
\begin_inset Formula 
\begin{align}
H_{t} & =\left[\frac{1-\alpha}{\chi}C_{t}^{-\nu}Z_{t}K_{t}^{\alpha}\right]^{\frac{\eta}{1+\alpha\eta}}\nonumber \\
 & =H\left(Z_{t},K_{t},C_{t}\right)\label{eq:Lab_expr}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Knowing the labor supply we can compute the marginal productivity of capital.
 After substituting out 
\begin_inset Formula $H_{t}$
\end_inset

 the capital stock in 
\begin_inset Formula $t+1$
\end_inset

 is a function of 
\begin_inset Formula $K_{t}$
\end_inset

, 
\begin_inset Formula $Z_{t}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

 as well:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
K_{t+1} & =Z_{t}K_{t}^{\alpha}H_{t}^{1-\alpha}+\left(1-\delta\right)K_{t}-C_{t}\nonumber \\
 & =K\left(Z_{t},K_{t},C_{t}\right)\label{eq:Kn_expr}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
stnd_rbc_aux
\family default
 computes these three variables 
\begin_inset Formula $H_{t}$
\end_inset

, 
\begin_inset Formula $MPK_{t}$
\end_inset

 and 
\begin_inset Formula $K_{t+1}$
\end_inset

 (in logs):
\end_layout

\begin_layout Standard
\noindent
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function [LK_n,LMPK,LH] = stnd_rbc_aux(par,LK,LZ,LC) 
\end_layout

\begin_layout Plain Layout

% Get log(K_t+1), log(MPK_t) and log(H_t) 
\end_layout

\begin_layout Plain Layout

% for standard RBC model
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Hours worked (in logs):
\end_layout

\begin_layout Plain Layout

LH = par.eta/(1+par.alpha*par.eta) * ...
\end_layout

\begin_layout Plain Layout

	( -log(par.chi) -par.nu*LC + ...
\end_layout

\begin_layout Plain Layout

	log(1-par.alpha) + LZ + par.alpha*LK );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Marginal productivity of capital (in logs):
\end_layout

\begin_layout Plain Layout

LMPK = log(par.alpha) + LZ + (par.alpha-1)*(LK-LH);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Capital in next period (in logs):
\end_layout

\begin_layout Plain Layout

LK_n = log(exp(LZ + par.alpha*LK + (1-par.alpha)*LH)...
\end_layout

\begin_layout Plain Layout

	- exp(LC) + (1-par.delta)*exp(LK));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This function is called twice in the model function.
 The first time to calculate 
\begin_inset Formula $K_{t+1}$
\end_inset

 in Line 18 of Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

, and a second time to calculate the marginal productivity in 
\begin_inset Formula $t+1$
\end_inset

 in Line 41.
\end_layout

\begin_layout Subsubsection*
Euler residuals for given policy function
\end_layout

\begin_layout Standard
As mentioned before the model function needs to calculate the Euler residuals
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a given initial grid and policy function.
 For this purpose we rewrite the Euler equation.
 The policy function for consumption 
\begin_inset Formula $c_{t}$
\end_inset

 is a function of the state variables capital 
\begin_inset Formula $k_{t}$
\end_inset

 and Total Factor Productivity and 
\begin_inset Formula $z_{t}$
\end_inset

, where smaller case indicate logs.
 The theoretical policy function that exactly solves the model is 
\begin_inset Formula $c_{t}=c\left(k_{t},z_{t}\right)$
\end_inset

.
 The approximation is either a polynomial or spline, which is defined by
 a vector 
\begin_inset Formula $\theta^{j}$
\end_inset

 of parameters, 
\begin_inset Formula $\hat{c}_{t}=\hat{c}\left(k_{t},z_{t};\theta^{j}\right)$
\end_inset

, where hats indicate the approximation.
 For simplicity we write the approximation for the consumption level 
\begin_inset Formula $\hat{C}_{t}$
\end_inset

 as:
\begin_inset Formula 
\begin{align}
\hat{C}_{t} & =\hat{C}\left(K_{t},Z_{t};\theta^{j}\right)=\exp\left[\hat{c}\left(k_{t},z_{t};\theta^{j}\right)\right]\label{eq:RBC_pol_fun}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The Euler equation was defined in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}^{-\nu} & =\beta E_{t}\left\{ C_{t+1}^{-\nu}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}H_{t+1}^{1-\alpha}+1-\delta\right]\right\} \label{eq:RBC_Eul_repeated}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We need to substitute out consumption using 
\begin_inset Formula $\hat{C}_{t}=\hat{C}\left(K_{t},Z_{t};\theta^{q}\right)$
\end_inset

 for period 
\begin_inset Formula $t$
\end_inset

 choices, and 
\begin_inset Formula $\hat{C}_{t+1}=\hat{C}\left(K_{t+1},Z_{t+1};\theta^{p}\right)$
\end_inset

 for next period's choices, where 
\begin_inset Formula $\theta^{q}$
\end_inset

 and 
\begin_inset Formula $\theta^{p}$
\end_inset

 only differ for Time Iteration.
 In addition we substitute out 
\begin_inset Formula $K_{t+1}$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Kn_expr"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and 
\begin_inset Formula $H_{t+1}$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Lab_expr"
plural "false"
caps "false"
noprefix "false"

\end_inset

: 
\begin_inset Formula 
\begin{align*}
\hat{K}_{t+1} & =K\left(Z_{t},K_{t},\hat{C}\left(K_{t},Z_{t};\theta^{q}\right)\right)\\
\hat{H}_{t+1} & =H\left(Z_{t+1},\hat{K}_{t+1},\hat{C}_{t+1}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The residuals 
\begin_inset Formula $R$
\end_inset

 can now be written as a function of the state variables and the policy
 function 
\begin_inset Formula $\theta$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(K_{t},Z_{t};\theta\right) & =\beta E_{t}\left\{ \hat{C}_{t+1}^{-\nu}\left[Z_{t+1}\alpha\hat{K}_{t+1}^{\alpha-1}\hat{H}_{t+1}^{1-\alpha}+1-\delta\right]\right\} /\hat{C}{}_{t}^{-\nu}-1\label{eq:RBC_appr_Euler_res}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\hat{C}_{t}$
\end_inset

, 
\begin_inset Formula $\hat{K}_{t+1}$
\end_inset

, 
\begin_inset Formula $\hat{H}_{t+1}$
\end_inset

 and 
\begin_inset Formula $\hat{C}_{t+1}$
\end_inset

 are explicitly defined above.
 We have divided both sides of the Euler equation by 
\begin_inset Formula $\hat{C}{}_{t}^{-\nu}$
\end_inset

 to ensure that the approximation is good over the whole interval.
 Without this scaling the normalized Euler residuals will be larger for
 high levels of consumption.
 This is due to the risk aversion, which makes the absolute errors in equation
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:RBC_Eul_repeated"
plural "false"
caps "false"
noprefix "false"

\end_inset

 smaller for high levels of consumption.
\end_layout

\begin_layout Subsubsection*
Expected value and Gauss-Hermite quadrature
\end_layout

\begin_layout Standard
With stochastic shocks we have to calculate the expected value on the right-hand
-side of the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Eul_repeated"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for which we use Gauss-Hermite quadrature.
 The simplified notation for the right-hand-side of the Euler equation is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
E_{t}\left\{ \beta\hat{C}_{t+1}^{-\nu}\left[Z_{t+1}\alpha\hat{K}_{t+1}^{\alpha-1}\hat{H}_{t+1}^{1-\alpha}+1-\delta\right]\right\}  & \approx E_{t}P\left(k_{t},z_{t},z_{t+1};\theta\right)\label{eq:RHS_Eul}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where we use 
\begin_inset Formula $\theta$
\end_inset

 to denote both 
\begin_inset Formula $\theta^{p}$
\end_inset

and 
\begin_inset Formula $\theta^{q}$
\end_inset

 for simplicity.
\end_layout

\begin_layout Standard
The expression is approximated with Gauss-Hermite quadrature (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Full-model-description"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details) as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
E_{t}P\left(k_{t},z_{t},z_{t+1};\theta\right) & \approx\sum_{j=1}^{J}\frac{\omega_{j}}{\sqrt{\pi}}P\left(k_{t},z_{t},\rho_{z}z_{t}+\sigma_{z}\sqrt{2}\zeta_{j};\theta\right)\label{eq:RBC_Gauss-Hermite}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\zeta_{j}$
\end_inset

 are the Gauss-Hermite nodes, and 
\begin_inset Formula $\omega_{j}$
\end_inset

 are the Gauss-Hermite weights.
 These nodes and weights were set in Step 1A of our code (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-1:-Initialization"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.her.xi(jj)}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.her.wi(jj)}
\end_layout

\end_inset

, respectively.
\end_layout

\begin_layout Standard
In our code Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

 the Gauss-Hermite quadrature 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Gauss-Hermite"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is calculated as follows.
 We loop over the shocks and weights 
\begin_inset Formula $j$
\end_inset

 in Line 30 till 48.
 In Line 51 we sum over the weights to obtain the right-hand-side of the
 Euler equation.
\end_layout

\begin_layout Subsection*
Step 3B: Create function handle
\end_layout

\begin_layout Standard
The function handle of this model file needs to be passed as the argument
 
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

 to the function 
\family typewriter
solve_proj
\family default
, which solves the model (see Step 5 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-5:-Solving"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In our example we create the handle with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 3: Handle for objective function  
\end_layout

\begin_layout Plain Layout

% (ie.
 the model file)  
\end_layout

\begin_layout Plain Layout

fun_res     = @(POL)STND_RBC_proj(par,GRID,POL);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It should be noted that after a function handle has been created any changes
 to the inputs arguments (other than the variable 
\begin_inset Formula $POL$
\end_inset

) will 
\shape italic
not
\shape default
 change the function handle when it is called.
 For example in our program we create the function handle 
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

.
 If we change 
\begin_inset Formula $par.alpha$
\end_inset

 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.alpha = 0.5}
\end_layout

\end_inset

 after the handle has been created then the function handle 
\begin_inset Formula $fun\_res$
\end_inset

 will still use the original value 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.alpha = 0.36}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Step 4: Initial guess for the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-4:-Initial"

\end_inset


\end_layout

\begin_layout Standard
The initial guess for the policy function 
\begin_inset Formula $Y0$
\end_inset

 has to contain the values of the policy variable on the initial grid.
 The values 
\begin_inset Formula $Y0$
\end_inset

 are an input for the solver 
\family typewriter
solve_proj
\family default
:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Y0$
\end_inset

: the initial values of the policy variable on the initial grid in 
\begin_inset Formula $GRID.xx$
\end_inset

.
\end_layout

\begin_layout Standard
Good starting values are valuable for two reasons.
 The first is that most algorithms are not guaranteed to find a solution,
 although Time Iteration should theoretically converge to the solution under
 normal regularity conditions
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This does not necessarily mean that a numerical procedure will converge
 as well (see 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

, page 554 and 555).
\end_layout

\end_inset

.
 The second reason is that good starting values will significantly reduce
 computations time.
\end_layout

\begin_layout Standard
There are four methods for the initialization of a policy function which
 usually ensure convergence:
\end_layout

\begin_layout Itemize
Perturbation methods;
\end_layout

\begin_layout Itemize
Gradually changing parameters;
\end_layout

\begin_layout Itemize
Gradually increasing the grid size;
\end_layout

\begin_layout Itemize
Increasing the order of the approximation.
\end_layout

\begin_layout Subsubsection*
Perturbation solution
\end_layout

\begin_layout Standard
For most models an initialization of the policy function using a linear
 perturbation solution will be sufficient for convergence.
 Perturbation solutions can be obtained easily as a wide range of software
 packages are available.
 In addition the computation time is very short, so perturbation methods
 are the natural choice for an initial guess.
 It should be noted that one can also initialize the policy function with
 perturbation methods for models featuring an attracting limit cycle, the
 so called `saddle cycle' models 
\begin_inset CommandInset citation
LatexCommand citep
key "galizia2018saddle"
literal "false"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The toolbox 
\family typewriter
CSD
\family default
 in the folder `TOOLS' can obtain the perturbation solution for saddle cycle
 models with the function 
\family typewriter
pert_ana_csd_lim
\family default
.
 The essential part of this function is the code 
\family typewriter
InvSub
\family default
 developed by Dana Galizia.
 The toolbox 
\family typewriter
CSD
\family default
 is based on 
\family typewriter
CoRRAM
\family default
 (2018) for Matlab by Alfred Maussner (see 
\begin_inset CommandInset href
LatexCommand href
target "https://www.uni-augsburg.de/de/fakultaet/wiwi/prof/vwl/maussner/dgebook/"
literal "false"

\end_inset

).
 
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Gradually changing parameters
\end_layout

\begin_layout Standard
For some models we might easily obtain the solution by setting a parameter
 to a specific value (0 or 1 for example), such that a particular mechanism
 is shut down.
 We could add a loop that gradually changes the parameter value, where in
 each iteration the policy function is initiated at its value in the previous
 iteration.
\end_layout

\begin_layout Subsubsection*
Gradually increasing the size of the grid
\end_layout

\begin_layout Standard
It might be difficult to get a solution when the size of the grid is large.
 We could start with a small grid around the steady state such that a solution
 is found.
 The grid size can then be increased using a loop.
 Note that for Chebyshev polynomials the vector of coefficients depends
 on the boundaries of the grid, so when changing the grid one needs to account
 for that when supplying the initial guess.
\end_layout

\begin_layout Subsubsection*
Increasing the order of the approximation
\begin_inset CommandInset label
LatexCommand label
name "par:Increasing-the-order"

\end_inset


\end_layout

\begin_layout Standard
For the methods that use polynomials it is easier to obtain a low order
 approximation, so we could start with a first order polynomial, and then
 add higher order terms using a loop.
 This is especially useful for the methods that rely on Chebyshev polynomials,
 since the Chebyshev basis functions are orthogonal to each other.
\end_layout

\begin_layout Subsubsection*
Example Standard RBC model
\end_layout

\begin_layout Standard
In our example function 
\family typewriter
main_stnd_rbc_proj
\family default
 we initialize the policy function using the first order perturbation solution.
 The linear perturbation solution is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{c}\left(k_{t},z_{t}\right) & =\overline{c}+H_{y,k}\left(k_{t}-\overline{k}\right)+H_{y,z}\left(z_{t}-\overline{z}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The coefficient 
\begin_inset Formula $H_{y,k}$
\end_inset

 and 
\begin_inset Formula $H_{y,z}$
\end_inset

 are the first and second entry in 
\begin_inset Formula $PERT.Hy\textrm{\_}w$
\end_inset

 of our code.
 The initial guess for the policy function is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%Initial policy function (for given grid): 
\end_layout

\begin_layout Plain Layout

Y0 = log(SS.css) + ...
     
\end_layout

\begin_layout Plain Layout

	PERT.Hy_w(1,1)*(GRID.xx(:,1)-log(SS.kss)) + ...
     
\end_layout

\begin_layout Plain Layout

	PERT.Hy_w(1,2)*(GRID.xx(:,2)-log(SS.zss)); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have included two options to determine the coefficient in 
\begin_inset Formula $PERT.Hy\textrm{\_}w$
\end_inset

, which are chosen by setting 
\begin_inset Formula $par.opt.get\textrm{\_}pert\textrm{\_}sol$
\end_inset

 to either 0 or 1.
\end_layout

\begin_layout Standard
If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.opt.get_pert_sol == 0}
\end_layout

\end_inset

 the initial policy function is based on the perturbation solution that
 is already calculated for the given parameter values:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if par.opt.get_pert_sol == 0         
\end_layout

\begin_layout Plain Layout

  %Given parameters, perturbation solution:     
\end_layout

\begin_layout Plain Layout

  PERT.Hy_w = [0.3456,0.3525];
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.opt.get_pert_sol == 1}
\end_layout

\end_inset

 the program obtains the coefficients 
\begin_inset Formula $H_{y,k}$
\end_inset

 and 
\begin_inset Formula $H_{y,z}$
\end_inset

 by solving the model with perturbation techniques.
 In our code we obtain the perturbation solution using the 
\family typewriter
CSD
\family default
 toolbox, which is included in the folder `TOOLS'.
 One could calculate these coefficients with other software packages, such
 as 
\family typewriter
Dynare
\family default
.
 The model file for the perturbation solution is the function 
\family typewriter
STND_RBC_pert
\family default
 in the folder `Examples
\backslash
STND_RBC_mod'.
 
\end_layout

\begin_layout Standard
When this option is chosen the code executes:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

else% Solve model with pertubation 
\end_layout

\begin_layout Plain Layout

  % Symbolic model file: 
\end_layout

\begin_layout Plain Layout

  MOD = STND_RBC_pert;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  % Vector of parameters:     
\end_layout

\begin_layout Plain Layout

  MOD.par_val = [par.alpha,par.beta,...
         
\end_layout

\begin_layout Plain Layout

		par.delta,par.eta,par.nu,par.chi];     
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  % Vector of steady states:     
\end_layout

\begin_layout Plain Layout

  MOD.SS_vec  = [log(SS.kss),log(SS.zss),log(SS.css)];     
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  % Get solution:     
\end_layout

\begin_layout Plain Layout

  PERT = pert_ana_csd(MOD,par.rho_z,1,par.sigma_z); 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  clear MOD; 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Section
Step 5: Solving the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-5:-Solving"

\end_inset


\end_layout

\begin_layout Standard
The model is solved in Step 5.
 The function 
\family typewriter
solve_proj
\family default
 minimizes the Euler residuals, and will assign the optimal policy function
 to the structure 
\begin_inset Formula $POL$
\end_inset

.
 The function requires the inputs 
\begin_inset Formula $GRID$
\end_inset

, 
\begin_inset Formula $POL$
\end_inset

, the function handle of the model file 
\family typewriter
fun_res
\family default
, and the initial guess for the policy function 
\begin_inset Formula $Y0$
\end_inset

.
 In our example Step 5 is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 5: Solve the model 
\end_layout

\begin_layout Plain Layout

POL  = solve_proj(GRID,POL,fun_res,Y0);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
solve_proj
\family default
 internally assigns the policy function to 
\begin_inset Formula $POL$
\end_inset

.
 This policy function will be a spline or a polynomial depending on the
 method.
 It uses an iterative scheme to find the policy function that minimizes
 the Euler residuals.
 
\end_layout

\begin_layout Standard
For all methods except Time Iteration we solve the objective function directly
 with either 
\family typewriter
fsolve
\family default
 and 
\family typewriter
lsqnonlin
\family default
 of the 
\family typewriter
Optimization Toolbox
\family default
.
 For Time Iteration an updating technique is used that is especially useful
 for recursive problems.
 More details on the solution methods can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Solving-the-model"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
In the script 
\family typewriter
main_stnd_rbc_proj
\family default
 we plot the policy function using the model specific plotting function
 
\family typewriter
plot_pol_stnd_rbc
\family default
.
 The graphs show that the policy function in our example is close to log
 linear, also outside the grid.
 
\end_layout

\begin_layout Section
Step 6: Evaluating the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-6:-Evaluating"

\end_inset


\end_layout

\begin_layout Standard
Usually we will want to evaluate the policy function, for example to simulate
 the model.
 The policy function can be evaluated with the function 
\family typewriter
get_pol_var
\family default
, which we also used in the model function in Step 4.
 The input variables are the structure 
\begin_inset Formula $GRID$
\end_inset

, the policy function 
\begin_inset Formula $POL$
\end_inset

, and an 
\begin_inset Formula $m\times n$
\end_inset

 matrix with the state variables (
\begin_inset Formula $xx$
\end_inset

).
 Each of the 
\begin_inset Formula $n$
\end_inset

 column represents a state variable, and is 
\begin_inset Formula $m$
\end_inset

 is the number of data points.
 The output is the policy variable in a column vector (
\begin_inset Formula $m\times1$
\end_inset

).
\end_layout

\begin_layout Standard
We evaluate the policy function in a stochastic simulation.
 The simulation is calculated in the function 
\family typewriter
stnd_rbc_sim
\family default
.
 We call this function in the following block:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% Step 6: Evaluate policy function (in simulation) 
\end_layout

\begin_layout Plain Layout

opt_sim.TT      = 1500; % # periods in simulation 
\end_layout

\begin_layout Plain Layout

opt_sim.T_ini   = 10;   % ini.
 periods at steady state 
\end_layout

\begin_layout Plain Layout

opt_sim.rws     = 10;   % number of simulated series
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[SIM] = stnd_rbc_sim(par,SS,POL,GRID,opt_sim); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this code 
\begin_inset Formula $opt\_sim$
\end_inset

 is a structure which sets the number of periods in the simulation (
\begin_inset Formula $TT$
\end_inset

), the number of series to simulate (
\begin_inset Formula $rws$
\end_inset

), and also the initial number of periods at the deterministic steady state
 (
\begin_inset Formula $T\_ini$
\end_inset

).
\end_layout

\begin_layout Standard
The function 
\family typewriter
stnd_rbc_sim
\family default
 loops over time, and evaluates the policy function in each period:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Simulation in  \texttt{main\_stnd\_rbc\_proj}},label={pl:RBC_sim}"
inline false
status open

\begin_layout Plain Layout

% loop over time :
\end_layout

\begin_layout Plain Layout

for it = T_ini+1:T_ini+TT   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  % Calculate TFP (add shock) 
\end_layout

\begin_layout Plain Layout

  LZ(:,it) = par.rho_z * LZ(:,it-1) + par.sigma_z * epsilon(:,it); 
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

  % Calculate policy variable:     
\end_layout

\begin_layout Plain Layout

  LC(:,it) = get_pol_var(POL,[LK(:,it),LZ(:,it)],GRID);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  % Calculate K_t+1 and H_t:  
\end_layout

\begin_layout Plain Layout

  [LK(:,it+1),~,LH(:,it)] = stnd_rbc_aux(par,LK(:,it),LZ(:,it),LC(:,it));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The loop first calculates Total Factor Productivity (
\begin_inset Formula $LZ$
\end_inset

), which takes normally distributed shocks 
\begin_inset Formula $epsilon$
\end_inset

 as input.
 Next it evaluates the policy function for consumption (
\begin_inset Formula $LC$
\end_inset

) given the state variables 
\begin_inset Formula $LK(:,it)$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $LZ(:,it)$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 Finally it calculates capital in the next period 
\begin_inset Formula $LK(:,it+1)$
\end_inset

, and the auxiliary variable hours worked 
\begin_inset Formula $LH(:,it)$
\end_inset

 using the function 
\family typewriter
stnd_rbc_aux
\family default
, which we discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Performance
\begin_inset CommandInset label
LatexCommand label
name "sec:Performance_RBC"

\end_inset


\end_layout

\begin_layout Standard
In this section we review the computation time and accuracy for different
 specifications of the solution methods.
 We review all 5 methods with changing number of gridpoints, and for the
 polynomials different orders of the approximation.
 The results are shown in Table 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{table:performance_rbc}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The computation time includes the calculation of the first order perturbation
 solution for the initial guess of the policy function, and the construction
 of the grid.
 The errors are the normalized Euler residuals calculated as in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1992projection"
literal "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
ERR & =\frac{\left[\beta E_{t}\left\{ \hat{C}_{t+1}^{-\nu}\left[Z_{t+1}\alpha\hat{K}_{t+1}^{\alpha-1}\hat{H}_{t+1}^{1-\alpha}+1-\delta\right]\right\} \right]^{-\nu}-\hat{C}_{t}}{\hat{C}_{t}}\label{eq:RBC_normal_Eul_error}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where the expectation term is calculated using Gauss-Hermite quadrature
 as before with the same amount of nodes as in the estimation.
 The errors are calculated using an equidistant grid with 1001 by 1001 nodes,
 and the same boundaries as used in the approximation.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{threeparttable}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Computation time and accuracy}                     
\end_layout

\begin_layout Plain Layout


\backslash
label{table:res_rbc}  
\end_layout

\begin_layout Plain Layout


\backslash
centering                                
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{l|ccccc} 
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{5}{c}{Min.
 Sq.
 Errors, Chebyshev}
\backslash

\backslash
           
\end_layout

\begin_layout Plain Layout


\backslash
hline                             
\end_layout

\begin_layout Plain Layout

Order & 2 & 3 & 4 & 5 & 5 
\backslash

\backslash
                          
\end_layout

\begin_layout Plain Layout

Nodes & 3 & 4 & 5 & 6 & 11 
\backslash

\backslash
                         
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.20 & 0.18 & 0.22 & 0.27 & 0.32 
\backslash

\backslash
      
\end_layout

\begin_layout Plain Layout

Avg.
 error & -5.88 & -7.21 & -8.83 & -9.40 & -9.40 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Max.
 error & -5.22 & -6.56 & -7.79 & -8.00 & -8.00 
\backslash

\backslash
  
\end_layout

\begin_layout Plain Layout


\backslash
hline   
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{5}{c}{Galerkin, Chebyshev}
\backslash

\backslash
              
\end_layout

\begin_layout Plain Layout


\backslash
hline                      
\end_layout

\begin_layout Plain Layout

Order & 2 & 3 & 4 & 5 & 5 
\backslash

\backslash
                          
\end_layout

\begin_layout Plain Layout

Nodes & 3 & 4 & 5 & 6 & 11 
\backslash

\backslash
                         
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.20 & 0.19 & 0.23 & 0.33 & 0.39 
\backslash

\backslash
      
\end_layout

\begin_layout Plain Layout

Avg.
 error & -5.88 & -7.21 & -8.83 & -10.52 & -10.52 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Max.
 error & -5.20 & -6.58 & -7.78 & -9.91 & -9.91 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{5}{c}{Time Iteration, cubic spline}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

Nodes & 5 & 7 & 11 & 15 & 21 
\backslash

\backslash
                       
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.64 & 0.63 & 0.70 & 0.78 & 1.12 
\backslash

\backslash
      
\end_layout

\begin_layout Plain Layout

Avg.
 error & -7.06 & -7.47 & -8.01 & -8.31 & -8.41 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Max.
 error & -6.45 & -6.78 & -7.24 & -7.64 & -7.95 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
hline   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{5}{c}{Direct Computation, cubic spline}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
hline             
\end_layout

\begin_layout Plain Layout

Nodes & 5 & 7 & 11 & 15 & 21 
\backslash

\backslash
                       
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.20 & 0.20 & 0.29 & 0.47 & 1.32 
\backslash

\backslash
      
\end_layout

\begin_layout Plain Layout

Avg.
 error & -7.06 & -7.47 & -8.03 & -8.41 & -8.82 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Max.
 error & -6.45 & -6.76 & -7.17 & -7.53 & -7.89 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{5}{c}{Min.
 Sq.
 Errors, monomials}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

Order & 1 & 2 & 3 & 4 & 5 
\backslash

\backslash
                          
\end_layout

\begin_layout Plain Layout

Nodes & 2 & 3 & 4 & 5 & 6 
\backslash

\backslash
                         
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.18 & 0.16 & 0.18 & 0.21 & 0.26 
\backslash

\backslash
      
\end_layout

\begin_layout Plain Layout

Avg.
 error & -3.60 & -5.70 & -7.07 & -8.61 & -7.00 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

Max.
 error & -3.28 & -5.41 & -6.79 & -7.91 & -6.84 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tablenotes}[flushleft] 
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
textit{
\backslash
small The number of nodes refers to the nodes for each of the two state
 variables.
 Computation times in seconds.
 Errors are normalized Euler residuals as in Judd (1992), in absolute values
 and log10.
 The average errors are the log10 of the average absolute errors.}      
\end_layout

\begin_layout Plain Layout


\backslash
end{tablenotes}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{threeparttable}                                        
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
From the table we conclude that the methods using Chebyshev polynomials
 are both fast and accurate.
 The accuracy increases especially with the order of the approximation.
 Note that order 1, 2, 3, 4 and 5 complete polynomials in two dimensions
 have 3, 6, 10, 15 and 21 parameters, respectively.
 Adding extra nodes for a given order has little effect as shown in the
 last two columns for the methods using Chebyshev polynomials.
 The table shows that monomial basis functions are not effective, since
 they are much less accurate than the Chebyshev polynomials.
 The explanation is that monomials are badly scaled, and not orthogonal,
 which makes it more difficult to identify the coefficients as they might
 be highly correlated
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It should be noted that Chebyshev polynomials can be transformed into a
 polynomial with monomial basis functions, so theoretically monomials can
 achieve the same accuracy as Chebyshev polynomials.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The computation time for the methods relying on splines is higher, and they
 are also less accurate than the methods using Chebyshev polynomials.
 The errors with Time Iteration and Direct Computation are similar.
 The reason is that errors are primarily caused by interpolation between
 gridpoints as errors at the gridpoints are much smaller.
 Setting more demanding stopping criteria will therefore have little effect
 on the accuracy of the spline methods.
\end_layout

\begin_layout Standard
Although not the most accurate Time Iteration has better convergence properties
 as regular problems should theoretically converge to the correct solution
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Numerical convergence is not guaranteed, see 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

, page 555.
\end_layout

\end_inset

.
 This is not the case for the methods using polynomials or Direct Computation.
 These latter methods might also converge to the unstable solution, which
 violates the Transversality Condition.
 For a low number of gridpoints
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The tipping point seems to be around 300 gridpoints.
\end_layout

\end_inset

 Direct Computation is faster than Time Iteration, because Time Iteration
 converges linearly at best 
\begin_inset CommandInset citation
LatexCommand citep
after "page 554"
key "judd1998numerical"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Subsection*
Sensitivity Gauss-Hermite quadrature
\end_layout

\begin_layout Standard
To investigate the effect of the number of Gauss-Hermite nodes on the policy
 function we plot the policy function for different number of Gauss-Hermite
 nodes.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GH_analysis"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the difference with the solution for 5 Gauss-Hermite nodes is plotted.
 The other state variable, capital, is set at its non-stochastic steady
 state.
 The differences within the boundaries of the grid are of the order 
\begin_inset Formula $10^{-7}$
\end_inset

.
 It should be noted that we have included 2 and 8 nodes in the figure, because
 they showed the largest differences in the policy function.
 The differences are smaller with 6, 7 and 9 nodes.
 Given the small differences we may conclude that the policy function is
 relatively insensitive to the number of Gauss-Hermite nodes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Difference in policy function, relative to 5 Gauss-Hermite nodes
\begin_inset CommandInset label
LatexCommand label
name "fig:GH_analysis"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ../../PROMES_v04.03/TEXT/FIGURES/fig_gh_nodes.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.4cm} 
\end_layout

\begin_layout Plain Layout


\backslash
it{Vertical dotted lines are the boundaries of the grid used in the approximatio
n.}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Multiple policy variables
\begin_inset CommandInset label
LatexCommand label
name "chap:Multiple-policy-variables"

\end_inset


\end_layout

\begin_layout Standard
This chapter illustrates how a model with multiple policy variables can
 be solved.
 We use a simple RBC model with an extra asset, housing.
 This `Housing Model' (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Housing-model"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more model details) is solved in the program 
\family typewriter
main_housing_proj
\family default
 found in the folder `Examples'.
 This chapter focuses on the two main differences of solving a model with
 multiple policy variables compared to models with one policy variable discussed
 so far.
 
\end_layout

\begin_layout Standard
The first difference is that each policy variable gets an index.
 The index is determined by the column index of the variable in the initial
 guess for the policy function.
 For example if we have two policy variables 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

, and the initial guess is 
\begin_inset Formula $Y0=\left[a_{0},b_{0}\right]$
\end_inset

 then variable 
\begin_inset Formula $a$
\end_inset

 gets index 
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

 and variable 
\begin_inset Formula $b$
\end_inset

 index 
\begin_inset Formula $i\textrm{\_}pol=2$
\end_inset

.
 The index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 is used when evaluating the policy function with 
\family typewriter
get_pol_var
\family default
.
 
\end_layout

\begin_layout Standard
The second difference is that the residuals of the model function need to
 be grouped.
 Assume there are two residual vectors 
\begin_inset Formula $R_{a}$
\end_inset

 and 
\begin_inset Formula $R_{b}$
\end_inset

, both with length 
\begin_inset Formula $m$
\end_inset

.
 The output of the model function needs to be the 
\begin_inset Formula $\left(2\cdot m\right)$
\end_inset

 by 1 vector 
\begin_inset Formula $R=\left[R_{a}^{\intercal},R_{b}^{\intercal}\right]^{\intercal}$
\end_inset

.
 Stacking the residual vectors vertically ensures that row 
\begin_inset Formula $i$
\end_inset

 and row 
\begin_inset Formula $i+m$
\end_inset

 in 
\begin_inset Formula $R$
\end_inset

 refer to the same gridpoint.
 In addition for Galerkin's method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 the order of the residuals should match the order of the policy variables.
 For example, if policy variables 
\begin_inset Formula $a$
\end_inset

 affects 
\begin_inset Formula $R_{a}$
\end_inset

 directly, and 
\begin_inset Formula $b$
\end_inset

 affects 
\begin_inset Formula $R_{b}$
\end_inset

 directly, then 
\begin_inset Formula $R_{a}$
\end_inset

 and 
\begin_inset Formula $R_{b}$
\end_inset

 should be stacked vertically in the same order as 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 were stacked horizontally in 
\begin_inset Formula $Y0$
\end_inset

.
\end_layout

\begin_layout Section
Housing model
\end_layout

\begin_layout Standard
The model consists of three state variables, which are capital 
\begin_inset Formula $K_{t}$
\end_inset

, housing 
\begin_inset Formula $D_{t}$
\end_inset

 and Total Factor Productivity 
\begin_inset Formula $Z_{t}$
\end_inset

.
 We use two policy variables, which are capital in the next period, 
\begin_inset Formula $K_{t+1}$
\end_inset

 and current period consumption 
\begin_inset Formula $C_{t}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Using 
\begin_inset Formula $D_{t+1}$
\end_inset

 as second policy variable will result in worse convergence for most algorithms,
 since the marginal utility of consumption 
\begin_inset Formula $\lambda$
\end_inset

 will be affected directly by both 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $D_{t+1}$
\end_inset

 through the budget constraint.
 With 
\begin_inset Formula $C_{t}$
\end_inset

 as policy variable the marginal utility of consumption in 
\begin_inset Formula $t+1$
\end_inset

 will only be affected indirectly by 
\begin_inset Formula $K_{t+1}$
\end_inset

.
 This helps solving the model more effectively.
\end_layout

\end_inset

.
 The model is captured by five equations (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Housing-model"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1}+D_{t+1} & \leq Z_{t}K_{t}^{\alpha}+\left(1-\delta_{k}\right)K_{t}+\left(1-\delta_{d}\right)D_{t}\label{eq:HOUS_budget-1}\\
C_{t}^{-\nu} & =\lambda_{t}\label{eq:HOUS_lambda}\\
\lambda_{t} & =\beta E_{t}\left\{ \lambda_{t+1}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}+1-\delta_{k}\right]\right\} \label{eq:HOUS_eul_k-1}\\
\lambda_{t} & =\beta E_{t}\left\{ \varrho D_{t+1}^{-\eta}+\lambda_{t+1}\left(1-\delta_{d}\right)\right\} \label{eq:HOUS_eul_d-1}\\
z_{t} & =\rho_{z}z_{t-1}+\sigma_{z}\epsilon_{t}\label{eq:HOUS_TFP}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where smaller cases indicate logs, ie.
 
\begin_inset Formula $z_{t}=\log\left(Z_{t}\right)$
\end_inset

.
 Housing is 
\begin_inset Formula $D$
\end_inset

, capital is 
\begin_inset Formula $K$
\end_inset

, consumption is 
\begin_inset Formula $C$
\end_inset

, the multiplier on the budget constraint is 
\begin_inset Formula $\lambda$
\end_inset

, productivity is 
\begin_inset Formula $Z$
\end_inset

, the autocorrelation coefficient 
\begin_inset Formula $\rho_{z}$
\end_inset

 , and the standard deviation of the shocks 
\begin_inset Formula $\sigma_{z}$
\end_inset

.
 The shocks are standard normally distributed, ie.
 
\begin_inset Formula $\epsilon_{t}\sim\mathcal{N}\left(0,1\right)$
\end_inset

.
 Note that equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_k-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the Euler equation for capital, and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_d-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the Euler equation for housing.
\end_layout

\begin_layout Section
Policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:HOUS_pol_fun"

\end_inset


\end_layout

\begin_layout Standard
The model consists of three state variables, 
\begin_inset Formula $K_{t}$
\end_inset

, 
\begin_inset Formula $D_{t}$
\end_inset

 and 
\begin_inset Formula $Z_{t}$
\end_inset

.
 We solve the model by approximating the policies for 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

.
 The policy function for capital in the next period is 
\begin_inset Formula $K_{t+1}=\hat{K}\left(K_{t},H_{t},Z_{t};\theta^{1}\right)=\exp\left[\hat{k}\left(k_{t},h_{t},z_{t};\theta^{1}\right)\right]$
\end_inset

.
 The policy function for consumption is 
\begin_inset Formula $C_{t}=\hat{C}\left(K_{t},H_{t},Z_{t};\theta^{2}\right)=\exp\left[\hat{c}\left(k_{t},h_{t},z_{t};\theta^{2}\right)\right]$
\end_inset

.
 The superscript 
\begin_inset Formula $j$
\end_inset

 in 
\begin_inset Formula $\theta^{j}$
\end_inset

 is the index of the policy variable.
 This index is determined by the column index of the initial guess 
\begin_inset Formula $Y0$
\end_inset

.
 To ensure capital gets index 
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

 we put capital in the first column of 
\begin_inset Formula $Y0$
\end_inset

, and housing in the second column.
 The initial guess is based on the first order perturbation solution:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%pre-allocate dimensions   
\end_layout

\begin_layout Plain Layout

Y0 = NaN(GRID.mm,2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Initial guess for capital:    
\end_layout

\begin_layout Plain Layout

Y0(:,1) = log(SS.Kss) + ...
         
\end_layout

\begin_layout Plain Layout

  0.9608*(GRID.xx(:,1)-log(SS.Kss)) +...
\end_layout

\begin_layout Plain Layout

  0.0540*(GRID.xx(:,2)-log(SS.Dss)) +...
\end_layout

\begin_layout Plain Layout

  0.0829*(GRID.xx(:,3)-log(SS.Zss));
\end_layout

\begin_layout Plain Layout

                          
\end_layout

\begin_layout Plain Layout

%Initial guess for consumption:     
\end_layout

\begin_layout Plain Layout

Y0(:,2) = log(SS.Css) + ...
\end_layout

\begin_layout Plain Layout

  0.4722*(GRID.xx(:,1)-log(SS.Kss)) +...
\end_layout

\begin_layout Plain Layout

  0.0266*(GRID.xx(:,2)-log(SS.Dss)) +...
\end_layout

\begin_layout Plain Layout

  0.3865*(GRID.xx(:,3)-log(SS.Zss));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $Y0$
\end_inset

 we have determined the indices 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 of the policy variables.
 When calling 
\family typewriter
get_pol_var
\family default
 the fourth argument has to be set to 
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

 to obtain capital 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $i\textrm{\_}pol=2$
\end_inset

 to obtain consumption 
\begin_inset Formula $C_{t}$
\end_inset

.
 For Time Iteration the policy variables are the columns in 
\begin_inset Formula $POL.YY$
\end_inset

 in the same order as in 
\begin_inset Formula $Y0$
\end_inset

.
 In our example we evaluate the policy function at the initial grid as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

LK = GRID.xx(:,1);%first state variable,    log(K_t) 
\end_layout

\begin_layout Plain Layout

LD = GRID.xx(:,2);%second state variable,   log(D_t) 
\end_layout

\begin_layout Plain Layout

LZ = GRID.xx(:,3);%third state variable,    log(Z_t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%policy variables, log(K_t+1) and  log(C_t): 
\end_layout

\begin_layout Plain Layout

if ~strcmp(POL.sol_meth,'tmi')%standard format:     
\end_layout

\begin_layout Plain Layout

  %use initial grid for 'gal', 'mse', and 'mono':     
\end_layout

\begin_layout Plain Layout

  spec_opt    = 1;           
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  % fourth input is index for pol.
 var.
 (i_pol):     
\end_layout

\begin_layout Plain Layout

  LK_n = get_pol_var(POL,[LK,LD,LZ],GRID,1,spec_opt);     
\end_layout

\begin_layout Plain Layout

  LC = get_pol_var(POL,[LK,LD,LZ],GRID,2,spec_opt);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

elseif strcmp(POL.sol_meth,'tmi')% for 'tmi'	
\end_layout

\begin_layout Plain Layout

  %Policy variables in columns of POL.YY :     
\end_layout

\begin_layout Plain Layout

  LK_n  = POL.YY(:,1);     
\end_layout

\begin_layout Plain Layout

  LC  = POL.YY(:,2); 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Section
Residuals
\begin_inset CommandInset label
LatexCommand label
name "sec:HOUS_residuals"

\end_inset


\end_layout

\begin_layout Standard
The Euler residuals are calculated similarly to the standard RBC example
 discussed in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For given policies for 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

 we can determine housing 
\begin_inset Formula $D_{t+1}$
\end_inset

 from the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{D}_{t+1} & =Z_{t}K_{t}^{\alpha}+\left(1-\delta_{k}\right)K_{t}+\left(1-\delta_{d}\right)D_{t}-\hat{K}\left(K_{t},H_{t},Z_{t};\theta^{k}\right)-\hat{C}\left(K_{t},H_{t},Z_{t};\theta^{c}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The multiplier 
\begin_inset Formula $\lambda_{t}$
\end_inset

 is defined by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_lambda"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
As in the other models we need to evaluate next period's policy functions.
 Next period's choice determines 
\begin_inset Formula $\hat{C}_{t+1}$
\end_inset

, and enables us to calculate the two residual functions 
\begin_inset Formula $R^{1}$
\end_inset

 and 
\begin_inset Formula $R^{2}$
\end_inset

, corresponding to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_k-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_d-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, respectively
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See Step 3A in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details on how to approximate the expected value using Gauss-Hermite
 quadrature.
 
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
R^{1} & =\beta E_{t}\left\{ \hat{\lambda}_{t+1}\left[Z_{t+1}\alpha\hat{K}_{t+1}^{\alpha-1}+1-\delta_{k}\right]\right\} /\hat{\lambda}_{t}-1\\
R^{2} & =\beta E_{t}\left\{ \varrho\hat{D}_{t+1}^{-\eta}+\hat{\lambda}_{t+1}\left(1-\delta_{d}\right)\right\} /\hat{\lambda}_{t}-1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where we divided both sides of the Euler equation with 
\begin_inset Formula $\lambda$
\end_inset

 to get more equally distributed normalized errors as explained in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 In our model function we stack the residual vectors vertically, such that
 
\begin_inset Formula $RES$
\end_inset

 is a 
\begin_inset Formula $\left(2\cdot m\right)$
\end_inset

 by 1 vector:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% Euler residuals  
\end_layout

\begin_layout Plain Layout

RES1    = sum(rhs_j1,2)/lambda - 1; 
\end_layout

\begin_layout Plain Layout

RES2 	= sum(rhs_j2,2)/lambda - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% RES1 and RES2 are mm by 1 vectors
\end_layout

\begin_layout Plain Layout

% concatenated vertically: 
\end_layout

\begin_layout Plain Layout

RES = [RES1;RES2];
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Note that the first residual vector 
\begin_inset Formula $RES1$
\end_inset

 is more directly linked with the first policy variable 
\begin_inset Formula $K_{t+1}$
\end_inset

.
 For the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 this requires that the residual vector 
\begin_inset Formula $RES1$
\end_inset

 comes first when stacking the residual vectors vertically, because 
\begin_inset Formula $K_{t+1}$
\end_inset

 was also the first policy variables (
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

).
 This ordering for Galerkin's method is required, because the coefficients
 of each policy function are set such that the corresponding residuals are
 orthogonal to the polynomial terms.
 
\end_layout

\begin_layout Part
Technical descriptions
\begin_inset CommandInset label
LatexCommand label
name "part:Function-descriptions"

\end_inset


\end_layout

\begin_layout Chapter
Model file
\begin_inset CommandInset label
LatexCommand label
name "chap:Model-file"

\end_inset


\end_layout

\begin_layout Standard
The model should be a function that takes the grid and the policy functions
 as inputs and gives the Euler residuals as output.
 In the main program one should create a handle to this model function,
 which only takes the structure with the policy function 
\begin_inset Formula $POL$
\end_inset

 as input.
 It is recommended to use the function 
\family typewriter
get_pol_var
\family default
 (described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function_get_pol_var"
plural "false"
caps "false"
noprefix "false"

\end_inset

) to evaluate the policy function inside the model function.
 This function takes a 
\begin_inset Formula $m\times n$
\end_inset

  matrix as input, where each column vector represents a state variable,
 and each row a gridpoint or datapoint.
 The output is a 
\begin_inset Formula $m\times d$
\end_inset

 matrix, where each column represents a policy variable.
 For examples of model functions see Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The model file can use two formats.
 The standard format, which is used for all methods except Time Iteration,
 and the format specific for Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

).
 The two formats are explained in more detail below.
 It should further be noted that it is recommended for the methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 to evaluate the policy function in period 
\begin_inset Formula $t$
\end_inset

 at the initial grid by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt=1}
\end_layout

\end_inset

 when calling 
\family typewriter
get_pol_var
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This option has no effect when used in combination with the methods relying
 on splines (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

).
\end_layout

\end_inset

.
 This setting will reduce computation time as the initial grid is not reconstruc
ted in every call of the model function.
\end_layout

\begin_layout Standard
The model function itself can include any amount of input fields, but needs
 to include at least:
\end_layout

\begin_layout Itemize
\begin_inset Formula $GRID$
\end_inset

: a structure with all necessary properties of the grid as assigned by the
 function 
\family typewriter
prep_grid
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`prep_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure that needs to contain the solution method 
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

, and the policy function (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-'solve_proj'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Note that a policy function will be assigned to 
\begin_inset Formula $POL$
\end_inset

 by the function 
\family typewriter
solve_proj
\family default
, based on the solution method and the initial guess.
\end_layout

\begin_layout Standard
The output of the function needs to be:
\end_layout

\begin_layout Itemize
\begin_inset Formula $RES$
\end_inset

: residuals in a 
\begin_inset Formula $\left(d\cdot m\right)$
\end_inset

 by 1 column vector, where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints, and 
\begin_inset Formula $d$
\end_inset

 the number of policy functions.
 When multiple policy variables are used (
\begin_inset Formula $d>1$
\end_inset

) the residuals vectors should be stacked vertically as explained below.
\end_layout

\begin_layout Paragraph
Vertical concatenation of residuals
\end_layout

\begin_layout Standard
The residuals vectors need to be stacked vertically.
 An example of this ordering can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 To explain the ordering we assume there are two policy variables (
\begin_inset Formula $d=2$
\end_inset

), and the total number of gridpoints is 
\begin_inset Formula $m$
\end_inset

.
 As 
\begin_inset Formula $d=2$
\end_inset

 there are two residuals functions 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

, which are both column vectors with length 
\begin_inset Formula $m$
\end_inset

.
 These vectors need to be stacked vertically such that the model function
 returns a 
\begin_inset Formula $\left(2\cdot m\right)$
\end_inset

 by 1 residual vector 
\begin_inset Formula $R=\left[R_{1}^{\intercal},R_{2}^{\intercal}\right]^{\intercal}$
\end_inset

.
 Grouping the residuals this way ensures that row 
\begin_inset Formula $j$
\end_inset

 and row 
\begin_inset Formula $j+m$
\end_inset

 in 
\begin_inset Formula $R$
\end_inset

 refer to the same gridpoint.
 This format is necessary, because the Jacobian for Time Iteration is calculated
 based on this format as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Time-iteration"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
In addition the order of the residual vectors should correspond to the order
 of the policy variables.
 In the example of Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we had an Euler equation for capital and an Euler equation for consumption.
 The complete residual vector is constructed as 
\begin_inset Formula $R=\left[R_{1}^{\intercal},R_{2}^{\intercal}\right]^{\intercal}$
\end_inset

.
 As capital is the first policy variable the Euler residuals for capital
 should be in 
\begin_inset Formula $R_{1}$
\end_inset

 and the other Euler residuals in 
\begin_inset Formula $R_{2}$
\end_inset

.
 This ordering ensures for the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 that the coefficients of the capital policy function are set such that
 the Euler residuals for capital are orthogonal to the corresponding polynomial
 terms (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Galerkin"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Subsection*
Formats for evaluation of policy function
\end_layout

\begin_layout Standard
There are two formats for the evaluation of a policy function in the model
 file.
 In the standard format the same policy function is used for this period's
 and next period's choices, which is used for all methods except Time Iteration.
 In the format for Time Iteration the policy function of the current iteration
 is used for this period's choices, while the previous iteration is used
 for next period's choices.
 This is explained in more details below, and examples are shown in Listing
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In general, assume we have one policy variable 
\begin_inset Formula $y_{t}$
\end_inset

.
 The theoretical policy function is then 
\begin_inset Formula $y_{t}=y\left(\mathbf{x}_{t}\right)$
\end_inset

, where 
\begin_inset Formula $\mathbf{x}_{t}$
\end_inset

 is the vector of state variables.
 This policy function is approximated with 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\hat{y}_{t}=\hat{y}\left(\mathbf{x}_{t};\theta^{j}\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
.
 The vector 
\begin_inset Formula $\theta^{j}$
\end_inset

 contains the parameters of either a polynomial or a spline
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that the parameters 
\begin_inset Formula $\theta$
\end_inset

 of a spline are determined by the policy variable at the initial grid.
\end_layout

\end_inset

, where 
\begin_inset Formula $j$
\end_inset

 refers to the iteration number.
 
\end_layout

\begin_layout Standard
The function 
\family typewriter
get_pol_var
\family default
 carries out the policy function evaluation given the state variables 
\begin_inset Formula $\mathbf{x}_{t}$
\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function_get_pol_var"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This function has two special options.
 One is to use the initial grid by setting 
\begin_inset Formula $spec\textrm{\_}opt=1$
\end_inset

.
 The other is to use the policy function of the previous iteration by setting
 
\begin_inset Formula $spec\textrm{\_}opt=2$
\end_inset

, which is required for Time Iteration.
 
\end_layout

\begin_layout Standard
In the example codes below we assume there are two state variables 
\begin_inset Formula $\mathbf{x}_{t}=\left[X1_{t},X2_{t}\right]$
\end_inset

, which are the column vectors 
\begin_inset Formula $X1\textrm{\_}t$
\end_inset

 and 
\begin_inset Formula $X2\textrm{\_}t$
\end_inset

.
\end_layout

\begin_layout Paragraph
Standard format
\end_layout

\begin_layout Standard
With the standard format the same policy function is used for current period's
 choices and next period's choices.
 We evaluate the policy function with index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 for period 
\begin_inset Formula $t$
\end_inset

 state variables as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

y_t = get_pol_var(POL,[X1_t,X2_t],GRID,i_pol);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 it is recommend to set 
\begin_inset Formula $spec\textrm{\_}opt=1$
\end_inset

 when evaluating the the policy function at the initial grid to save computation
 time:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\noindent

spec_opt =1;  
\end_layout

\begin_layout Plain Layout

y_t = get_pol_var(POL,[X1_t,X2_t],GRID,i_pol,spec_opt);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
With this option the inputs arguments 
\begin_inset Formula $\left[X1_{t},X2_{t}\right]$
\end_inset

 will be ignored, but only for these three methods.
 For the other methods the option 
\begin_inset Formula $spec\textrm{\_}opt=1$
\end_inset

 is ignored.
\end_layout

\begin_layout Paragraph
Time iteration format
\end_layout

\begin_layout Standard
For Time iteration we use a slightly different format as the solver needs
 to evaluate two different policy functions as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Time-iteration"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and shown in the examples in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
For current period choices the solver has to evaluate 
\begin_inset Formula $Y_{t}$
\end_inset

, which is set directly by the algorithm in the field 
\begin_inset Formula $POL.YY$
\end_inset

.
 To evaluate the policy variable with index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 we call: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

y_t = POL.YY(:,i_pol);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For next period's choices we use the policy function of the previous iteration
 which is stored in 
\begin_inset Formula $POL.pp\textrm{\_}y\textrm{\_}old$
\end_inset

.
 This policy function is evaluated by setting the input argument 
\begin_inset Formula $spec\textrm{\_}opt=2$
\end_inset

 when calling 
\family typewriter
get_pol_var
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\noindent

spec_opt_next = 2;
\end_layout

\begin_layout Plain Layout

y_n = get_pol_var(POL,[X1_n,X2_n],GRID,i_pol,spec_opt_next);
\end_layout

\end_inset


\end_layout

\begin_layout Section
Function 
\family typewriter
get_pol_var
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function_get_pol_var"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
get_pol_var
\family default
 takes the policy function in 
\begin_inset Formula $POL$
\end_inset

, the state variables, and the grid structure 
\begin_inset Formula $GRID$
\end_inset

 as input and gives the policy variables as output.
 When multiple policy variables are used one needs to specify the index
 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 for the policy variable.
\end_layout

\begin_layout Standard
The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure which contains the field 
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Step-2B-Sol_meth"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the field containing the appropriate policy function.
 The function 
\family typewriter
solve_proj
\family default
 adds this policy function to 
\begin_inset Formula $POL$
\end_inset

.
 For methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 this is the field 
\begin_inset Formula $pp\textrm{\_}y$
\end_inset

, and for methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 this is the field 
\begin_inset Formula $theta$
\end_inset

.
 For method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 there are two special cases of the policy function.
 The current iteration policy function evaluated at the initial grid is
 the field 
\begin_inset Formula $YY$
\end_inset

, and the policy function of the previous iteration is the field 
\begin_inset Formula $pp\textrm{\_}y\textrm{\_}old$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: a matrix with the state variables in column vectors stacked behind each
 other (
\begin_inset Formula $m\times n$
\end_inset

  matrix, where 
\begin_inset Formula $m$
\end_inset

 is the number of points to be evaluated, and 
\begin_inset Formula $n$
\end_inset

 is the number of state variables) as shown in the above examples and in
 Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_sim}
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $GRID$
\end_inset

: structure with the necessary grid properties, which are assigned by 
\family typewriter
prep_grid
\family default
 (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The fields include the number of state variables 
\begin_inset Formula $n$
\end_inset

 for all methods.
 In addition they include 
\begin_inset Formula $order$
\end_inset

, 
\begin_inset Formula $lb$
\end_inset

, 
\begin_inset Formula $ub$
\end_inset

 and 
\begin_inset Formula $grid\_type$
\end_inset

 for the methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, and the fields 
\begin_inset Formula $order$
\end_inset

 and 
\begin_inset Formula $grid\_type$
\end_inset

 for the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{init_grid=1}
\end_layout

\end_inset

 (see below) 
\begin_inset Formula $GRID$
\end_inset

 also needs to include 
\begin_inset Formula $XX$
\end_inset

 for method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, or 
\begin_inset Formula $XX\textrm{\_}dw$
\end_inset

 for methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 (optional if 
\begin_inset Formula $d=1$
\end_inset

): the index of the policy variable to be evaluated.
 The total number of policy variables is 
\begin_inset Formula $d$
\end_inset

.
 The index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 is determined by the column index in the initial guess 
\begin_inset Formula $Y0$
\end_inset

 (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for an example);
\end_layout

\begin_layout Itemize
\begin_inset Formula $spec\textrm{\_}opt$
\end_inset

 (optional): if 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt=1}
\end_layout

\end_inset

 and the method is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 the initial grid (
\begin_inset Formula $XX$
\end_inset

 or 
\begin_inset Formula $XX\textrm{\_}dw$
\end_inset

) is used to calculate the policy function, which prevents the recalculation
 of the grid and the polynomial.
 This will save computation time for the methods relying on polynomials
 as the initial grid does not have to be reconstructed for every call of
 this function.
 Note that the input argument 
\begin_inset Formula $xx$
\end_inset

 will be ignored in this case.
 This optional setting has no effect when using the methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt=2}
\end_layout

\end_inset

 the field 
\begin_inset Formula $POL.pp\textrm{\_}y\textrm{\_}old$
\end_inset

 is used to evaluate the policy function.
 This field will be automatically assigned when solving the model with the
 method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

.
 If 
\begin_inset Formula $spec\textrm{\_}opt=0$
\end_inset

 or if the field 
\begin_inset Formula $spec\textrm{\_}opt$
\end_inset

 is empty the function carries out the standard evaluation with the input
 matrix 
\begin_inset Formula $xx$
\end_inset

.
\end_layout

\begin_layout Chapter
Solving the model
\begin_inset CommandInset label
LatexCommand label
name "chap:Solving-the-model"

\end_inset


\end_layout

\begin_layout Standard
The model is solved used the function 
\family typewriter
solve_proj
\family default
, which is explained in the following section.
 Each of the five algorithms are explained in the remaining sections of
 this chapter.
\end_layout

\begin_layout Section
Function 
\family typewriter
solve_proj
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-'solve_proj'"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
solve_proj
\family default
 solves for the policy function that minimizes the Euler residuals.
 To solve the model one calls the function 
\family typewriter
solve_proj
\family default
 with inputs:
\end_layout

\begin_layout Itemize
\begin_inset Formula $GRID$
\end_inset

: the structure with the grid properties assigned by 
\family typewriter
prep_grid
\family default
 as described in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure with the required field 
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

, that defines the solution method.
 There are several optional fields, which are listed in the subsection Optional
 Fields below;
\end_layout

\begin_layout Itemize
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

: the function handle to the model function as described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and examples in Listings 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $Y0$
\end_inset

: the initial guess of the policy functions evaluated at the initial grid
 
\begin_inset Formula $GRID.xx$
\end_inset

.
 
\begin_inset Formula $Y0$
\end_inset

 should be a 
\begin_inset Formula $m\times d$
\end_inset

  matrix, with 
\begin_inset Formula $m$
\end_inset

 the total number of gridpoints, and 
\begin_inset Formula $d$
\end_inset

 the number of policy variables.
 The column index of a variable in 
\begin_inset Formula $Y0$
\end_inset

 determines the index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

, which is used when evaluating the policy function with 
\family typewriter
get_pol_var
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function_get_pol_var"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and for an example Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 );
\end_layout

\begin_layout Itemize
\begin_inset Formula $opt\textrm{\_}display$
\end_inset

 (optional): set the option 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'Display'}
\end_layout

\end_inset

 for the solver (either 
\family typewriter
lsqnonlin
\family default
 or 
\family typewriter
fsolve)
\family default
.
 The default option is to set 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'Display'}
\end_layout

\end_inset

 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'off'}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure to which the policy function is added.
 For methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 the policy functions are in the field 
\begin_inset Formula $theta$
\end_inset

.
 This is a 
\begin_inset Formula $p\times d$
\end_inset

 matrix with the polynomial coefficients, where 
\begin_inset Formula $d$
\end_inset

 is the number of policy variables, and 
\begin_inset Formula $p$
\end_inset

 the number of polynomial terms.
 For methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 the policy function is 
\begin_inset Formula $pp\textrm{\_}y$
\end_inset

, which is 
\begin_inset Formula $1\times d$
\end_inset

 cell array.
 Each cell contains a spline for a policy variable.
 The splines are created using Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 The interpolation method is specified in 
\begin_inset Formula $POL.spl\textrm{\_}meth$
\end_inset

 for which 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cubic'}
\end_layout

\end_inset

 is the default option.
\end_layout

\begin_layout Standard
The solver uses the following functions from Matlab's 
\family typewriter
Optimization Toolbox
\family default
:
\end_layout

\begin_layout Itemize

\family typewriter
lsqnonlin
\family default
 for methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
fsolve
\family default
 for methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We use default options for 
\family typewriter
fsolve
\family default
 and 
\family typewriter
lsqnonlin
\family default
 with two exceptions.
 The first exception is the 
\family typewriter
fsolve
\family default
 algorithm, which is set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'trust-region'}
\end_layout

\end_inset

 for the method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

, because we need an algorithm that can handle sparse problems, including
 the option to set the pattern in the Jacobian matrix.
 For the methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 we use the default 
\family typewriter
fsolve
\family default
 algorithm.
 
\end_layout

\begin_layout Standard
The second exception was already mentioned and is the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'Display'}
\end_layout

\end_inset

 option, which is set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'off'}
\end_layout

\end_inset

 by default.
 To change other options of the solvers 
\family typewriter
fsolve
\family default
 and 
\family typewriter
lsqnonlin
\family default
 one will need to adjust the options inside the function 
\family typewriter
solve_proj
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The options for the solvers are set in the subfunction 
\family typewriter
set_default_opt_solver
\family default
.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection*
Solution Methods
\begin_inset CommandInset label
LatexCommand label
name "subsec:Solution_types"

\end_inset


\end_layout

\begin_layout Standard
In the exact solution of the model the policy variable 
\begin_inset Formula $y_{t}$
\end_inset

 is a function of the state variables: 
\begin_inset Formula $y_{t}=y\left(\mathbf{x}_{t}\right)$
\end_inset

 where 
\begin_inset Formula $\mathbf{x}_{t}$
\end_inset

 is the vector of state variables.
 We approximate this function using either a polynomial or spline: 
\begin_inset Formula $y\left(\mathbf{x}_{t}\right)=\hat{y}\left(\mathbf{x}_{t};\theta\right)$
\end_inset

 where 
\begin_inset Formula $\theta$
\end_inset

 is a vector of parameters that defines the polynomial or spline.
 The five solution types are listed below.
 
\end_layout

\begin_layout Standard
The five methods are:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

: the coefficients of a complete polynomial are set such that the Euler
 residuals are orthogonal to the polynomial terms
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See 
\begin_inset CommandInset citation
LatexCommand citealt
after "subsection 11.1"
key "judd1998numerical"
literal "false"

\end_inset

.
\end_layout

\end_inset

.
 The method uses Matlab's 
\family typewriter
fsolve
\family default
 with the default algorithm.
 The complete Chebyshev polynomial uses the Chebyshev nodes;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

: minimization of squared errors using Matlab's 
\family typewriter
lsqnonlin
\family default
.
 The policy function is a complete Chebyshev polynomial, determined using
 the Chebyshev nodes; 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

: solves the Euler residuals at all gridpoints using Time Iteration.
 This method theoretically converges to the solution
\begin_inset Foot
status open

\begin_layout Plain Layout
If the regularity conditions hold.
\end_layout

\end_inset

.
 The policy function is a spline as defined by Matlab's 
\family typewriter
griddedInterpolant
\family default
 and uses equidistant nodes.
 This methods uses Matlab's 
\family typewriter
fsolve
\family default
 with the algorithm set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'trust-region'}
\end_layout

\end_inset

, and the pattern in the Jacobian set in the option 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'JacobPattern'}
\end_layout

\end_inset

 as explained below;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

: directly solves the Euler residual at all gridpoints.
 The policy function is a spline as defined by Matlab's 
\family typewriter
griddedInterpolant
\family default
 and uses equidistant nodes.
 This method is not recommended for large grids (say, more than 500 gridpoints).
 The reason is that the method numerically estimates the full Jacobian of
 the system of equations.
 The Jacobian is an 
\begin_inset Formula $m\times m$
\end_inset

 matrix with 
\begin_inset Formula $m$
\end_inset

 being the total number of gridpoints.
 This makes it inefficient to numerically approximate the Jacobian for large
 grids;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

: minimization of squared errors using Matlab's 
\family typewriter
lsqnonlin
\family default
.
 The policy function uses monomial basis functions with an equidistant grid.
 This method is not recommended.
 The method will usually work for low order approximations, but results
 can be inaccurate.
\end_layout

\begin_layout Standard
The recommended methods are Minimization of Squared Errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

) and Galerkin (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

).
 Time Iteration and Direct Computation are good alternatives, if a polynomial
 might not approximate the policy function well.
 Direct Computation will work well for small grids.
 Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) is especially useful if convergence is an issue, or if the grid is large.
\end_layout

\begin_layout Subsection*
Optional fields
\end_layout

\begin_layout Standard
There are several optional fields in 
\begin_inset Formula $POL$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Polynomial methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $order$
\end_inset

: the order of the complete polynomial.
 See Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details.
\end_layout

\begin_layout Subsubsection*
Spline methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $spl\textrm{\_}meth$
\end_inset

: for the solution types 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 the interpolation method of the spline can be set in the optional field
 
\begin_inset Formula $POL.spl\textrm{\_}meth$
\end_inset

.
 The choices for the interpolation methods are described in the Matlab documenta
tion for the function 
\family typewriter
griddedInterpolant
\family default
.
 The default is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cubic'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Time Iteration 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the solution type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 there are the following options, which are fields in the structure 
\begin_inset Formula $POL$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $diff\textrm{\_}tol$
\end_inset

: the tolerance for the maximum absolute change in the the policy function
 between two iterations: 
\begin_inset Formula $\max\left|\hat{y}^{j}-\hat{y}^{j-1}\right|$
\end_inset

where 
\begin_inset Formula $\hat{y}^{j}$
\end_inset

 is the policy variable of iteration 
\begin_inset Formula $j$
\end_inset

.
 The default is 1e-6;
\end_layout

\begin_layout Itemize
\begin_inset Formula $res\textrm{\_}tol$
\end_inset

: the tolerance 
\begin_inset Formula $\epsilon_{\max}^{r}$
\end_inset

, which is the acceptance level for the maximum absolute value of the Euler
 residuals: 
\begin_inset Formula $\max\left|R\left(\hat{y}_{t}^{j};\theta^{j}\right)\right|$
\end_inset

.
 The default is 1e-8;
\end_layout

\begin_layout Itemize
\begin_inset Formula $max\textrm{\_}iter$
\end_inset

: the maximum number of iterations in the `
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'while'}
\end_layout

\end_inset

 loop.
 The default is 500;
\end_layout

\begin_layout Subsection*
Polynomial solutions
\end_layout

\begin_layout Standard
This subsection discusses some properties of the solution types 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

.
 For each of these methods the policy function is stored as 
\begin_inset Formula $POL.theta$
\end_inset

, where 
\begin_inset Formula $theta$
\end_inset

 is a 
\begin_inset Formula $p\times d$
\end_inset

 matrix with column vector of polynomial coefficients for each policy variable.
 To evaluate this policy function we can call the function 
\family typewriter
get_pol_var.
\end_layout

\begin_layout Subsubsection*
Initial guess of policy function
\end_layout

\begin_layout Standard
To get an initial guess for the policy function 
\begin_inset Formula $\theta_{0}$
\end_inset

 we regress the polynomial of the initial grid (
\begin_inset Formula $GRID.XX\textrm{\_}dw$
\end_inset

 or 
\begin_inset Formula $GRID.XX$
\end_inset

) on the guess for policy function 
\begin_inset Formula $Y0$
\end_inset

 with index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 at the gridpoints:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if strcmp(POL.sol_meth,'mse') || ...
\end_layout

\begin_layout Plain Layout

  	strcmp(POL.sol_meth,'gal')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  POL.theta0(:,i_pol) = GRID.XX_dw
\backslash
POL.Y0(:,i_pol); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

elseif strcmp(POL.sol_meth,'mono')     
\end_layout

\begin_layout Plain Layout

  POL.theta0(:,i_pol) = GRID.XX
\backslash
POL.Y0(:,i_pol);     
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*

\end_layout

\begin_layout Section
Minimization of Squared Errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "sec:MSE"

\end_inset


\end_layout

\begin_layout Standard
For the methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 the polynomial is defined by the coefficients 
\begin_inset Formula $\theta$
\end_inset

.
 The field 
\begin_inset Formula $POl.theta$
\end_inset

 is 
\begin_inset Formula $p\times d$
\end_inset

 matrix, where 
\begin_inset Formula $p$
\end_inset

 is the number of polynomial terms, and 
\begin_inset Formula $d$
\end_inset

 is the number of policy variables.
 Each policy variable is represented by a 
\begin_inset Formula $p\times1$
\end_inset

 vector.
 
\end_layout

\begin_layout Standard
The coefficients are determined by the minimization of the squared errors.
 The function handle 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{R=fun_res(POL)}
\end_layout

\end_inset

 gives us the residuals 
\begin_inset Formula $R$
\end_inset

 in a 
\begin_inset Formula $d\cdot m$
\end_inset

 column vector.
 
\begin_inset Formula $R$
\end_inset

 consists of 
\begin_inset Formula $m\times1$
\end_inset

 residuals 
\begin_inset Formula $R^{j}$
\end_inset

 for every policy variable 
\begin_inset Formula $j=1,\ldots,d$
\end_inset

.
 
\end_layout

\begin_layout Standard
The objective is to minimize the sum of the square residuals: 
\begin_inset Formula 
\begin{align}
\min_{\theta} & \sum_{j=1}^{d}\sum_{i=1}^{m}R^{j}\left(x_{i};\theta^{j}\right)^{2}\label{eq:mse_squared_error}
\end{align}

\end_inset

 where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints, 
\begin_inset Formula $d$
\end_inset

 is the number of policy variables, which are indexed by 
\begin_inset Formula $j$
\end_inset

.
 To minimize 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:mse_squared_error"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we use Matlab's 
\family typewriter
lsqnonlin
\family default
, which squares the residuals.
\end_layout

\begin_layout Section
Galerkin (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "sec:Galerkin"

\end_inset


\end_layout

\begin_layout Standard
The polynomial for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 is also defined by the coefficient vector 
\begin_inset Formula $\theta$
\end_inset

 (
\begin_inset Formula $POL.theta$
\end_inset

), which is a 
\begin_inset Formula $p$
\end_inset

 x 
\begin_inset Formula $d$
\end_inset

 matrix vector, where 
\begin_inset Formula $p$
\end_inset

 is the number of polynomial terms, and 
\begin_inset Formula $d$
\end_inset

 the number of policy variables.
 Policy variable 
\begin_inset Formula $j$
\end_inset

 is approximated by a 
\begin_inset Formula $p\times1$
\end_inset

  coefficient vector 
\begin_inset Formula $\theta^{j}$
\end_inset

.
\end_layout

\begin_layout Standard
The algorithm sets each coefficient 
\begin_inset Formula $\theta_{ip}^{j}$
\end_inset

 for 
\begin_inset Formula $ip=\left[1,2,\ldots,p\right]$
\end_inset

 such that the residuals are orthogonal to the corresponding polynomial
 term 
\begin_inset Formula $\tilde{X}_{ip}$
\end_inset

.
 The function handle 
\family typewriter
fun_res
\family default
 gives us the residuals 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $R^{j}\left(x_{i};\theta\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 for each policy variable 
\begin_inset Formula $j$
\end_inset

 in a column vector.
 As in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See equation 16.5.5 on page 561.
\end_layout

\end_inset

 the objective for each coefficient 
\begin_inset Formula $\theta_{ip}^{j}$
\end_inset

 for each policy variable 
\begin_inset Formula $j=1,\ldots,d$
\end_inset

 is: 
\begin_inset Formula 
\begin{align}
0 & =\sum_{i=1}^{m}R_{i}^{j}\left(x_{i};\theta\right)\tilde{X}_{i,ip}\label{eq:GAL_res}
\end{align}

\end_inset

where 
\begin_inset Formula $\tilde{X}_{i,ip}$
\end_inset

 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{XX_dw(i,ip)}
\end_layout

\end_inset

 in our code) is the value of the polynomial term at gridpoint 
\begin_inset Formula $i$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
For more details on the objective see Chapter 11 in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

.
\end_layout

\end_inset

.
 For each policy variable 
\begin_inset Formula $j$
\end_inset

 we have 
\begin_inset Formula $p$
\end_inset

 equations, resulting in a total of 
\begin_inset Formula $d\cdot p$
\end_inset

 equations.
 We solve this system of equations simultaneously with 
\family typewriter
fsolve
\family default
.
 
\end_layout

\begin_layout Standard
To give an example of equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:GAL_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

, assume we have one state variable, and we use a second order approximation.
 The coefficient vector is: 
\begin_inset Formula $\theta=\left[\begin{array}{ccc}
\theta_{1}, & \theta_{2}, & \theta_{3}\end{array}\right]^{\intercal}$
\end_inset

.
 The Chebyshev polynomial terms (in scaled down variables 
\begin_inset Formula $\tilde{x}$
\end_inset

) are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\tilde{X} & =\left[\begin{array}{ccc}
1, & \tilde{x}, & 2\tilde{x}^{2}-1\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
such that the approximation of the policy function is 
\begin_inset Formula $\hat{y}\left(x;\theta\right)=\theta_{1}+\theta_{2}\tilde{x}+\theta_{3}\left(2\tilde{x}^{2}-1\right)$
\end_inset

.
 For 
\begin_inset Formula $ip=3$
\end_inset

 we get 
\begin_inset Formula $\tilde{X}_{i,3}=2\tilde{x}_{i}^{2}-1$
\end_inset

, which is a 
\begin_inset Formula $m$
\end_inset

 x 1 vector.
 The coefficient 
\begin_inset Formula $\theta_{3}$
\end_inset

 is set such that the inner product of the vector of errors 
\begin_inset Formula $R\left(x;\theta\right)$
\end_inset

 and the vector 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\tilde{X}_{ip}$
\end_inset

 is zero.
\end_layout

\begin_layout Section
Time iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "sec:Time-iteration"

\end_inset


\end_layout

\begin_layout Standard
The policy functions for Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) are splines as defined by Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 The default interpolation method is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cubic'}
\end_layout

\end_inset

, but can be set to any of the other types allowed by Matlab in the optional
 field 
\begin_inset Formula $POL.spl\_meth$
\end_inset

.
 The algorithm updates the policy function using an iterative scheme.
 It solves the current policy function, when next period's choices are determine
d by the policy function of the last iteration.
 The residual at each gridpoint is therefore independent of the current
 policy at the other gridpoints.
 This makes the Jacobian sparse, such that we can solve each iteration efficient
ly.
 We first describe the method for one policy variable.
 For multiple variables the only difference is the pattern in the Jacobian
 matrix as explained below.
\end_layout

\begin_layout Standard
The Time Iteration algorithm is described by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

, and consists of three steps.
 We use the simple example of the deterministic Brock-Mirman model as described
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BM-Approx_solution"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is a special case of the model used by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset


\end_layout

\end_inset

.
 We start from equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_res_func"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and slightly change notation.
 We choose an initial grid 
\begin_inset Formula $K_{i,t}$
\end_inset

 for 
\begin_inset Formula $i=1,...,m$
\end_inset

.
 The objective is to solve the policy function 
\begin_inset Formula $\hat{C}_{i,t}^{j}$
\end_inset

 at each gridpoint 
\begin_inset Formula $i$
\end_inset

, given the policy function of the previous iteration.
 The capital stock in the next period at the gridpoints 
\begin_inset Formula $i$
\end_inset

 for current policy 
\begin_inset Formula $\hat{C}_{i,t}^{j}$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
K_{i,t+1} & =K_{i,t}^{\alpha}-\hat{C}_{i,t}^{j}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The old policy is defined by the spline fitted through the solution of the
 previous iteration.
 The parameters of the spline are 
\begin_inset Formula $\theta^{j-1}=\Omega\left(K_{t},\hat{C}_{t}^{j-1}\right)$
\end_inset

, where 
\begin_inset Formula $j-1$
\end_inset

 refers the previous iteration.
 The residual at gridpoint 
\begin_inset Formula $i$
\end_inset

, using the old parameterization 
\begin_inset Formula $\theta^{j-1}$
\end_inset

 for next period's choices, and the current policy 
\begin_inset Formula $\hat{C}_{i,t}^{j}$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(\hat{C}_{i,t}^{j},\theta^{j-1}\right) & =\frac{1}{\hat{C}_{i,t}^{j}}-\beta\frac{1}{\hat{C}\left(K_{i,t}^{\alpha}-\hat{C}_{i,t}^{j};\theta^{j-1}\right)}\alpha\left(K_{i,t}^{\alpha}-\hat{C}_{i,t}^{j}\right)^{\alpha-1}\label{eq:RES_tmi}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The old parameterization of the policy function 
\begin_inset Formula $\theta^{j-1}$
\end_inset

 is only used for next period's choices.
 This equation can be solved for 
\begin_inset Formula $\hat{C}_{i,t}^{j}$
\end_inset

 using a nonlinear equation solver.
\end_layout

\begin_layout Standard
For a single policy variable the solution 
\begin_inset Formula $\hat{C}_{i,t}^{j}$
\end_inset

 at each gridpoint does not affect the solution at other gridpoints.
 The Jacobian of this system of equations will only have entries on the
 diagonal: 
\begin_inset Formula 
\begin{align*}
J\left(C\right) & =\left[\begin{array}{cccc}
\frac{\partial R_{1}}{\partial C_{1}} & 0 & \cdots & 0\\
0 & \frac{\partial R_{2}}{\partial C_{2}} & 0 & \vdots\\
\vdots & 0 & \ddots & 0\\
0 & \cdots & 0 & \frac{\partial R_{m}}{\partial C_{m}}
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
With multiple policy variables the Jacobian will have diagonal blocks.
 Let matrix 
\begin_inset Formula $Q_{m}$
\end_inset

 be the 
\begin_inset Formula $m\times m$
\end_inset

  identity matrix, which is the pattern in the Jacobian for the single variable
 problem.
 For multiple variables the pattern consists of repeating blocks of 
\begin_inset Formula $Q_{m}$
\end_inset

.
 Assume we have two policy variables 
\begin_inset Formula $x^{1}$
\end_inset

 and 
\begin_inset Formula $x^{2}$
\end_inset

 with residuals 
\begin_inset Formula $R^{1}$
\end_inset

 and 
\begin_inset Formula $R^{2}$
\end_inset

.
 These residuals vectors 
\begin_inset Formula $R^{1}$
\end_inset

 and 
\begin_inset Formula $R^{2}$
\end_inset

 are stacked vertically in 
\begin_inset Formula $R$
\end_inset

.
 The value 
\begin_inset Formula $x_{i}^{1}$
\end_inset

 at gridpoint 
\begin_inset Formula $i$
\end_inset

 will affect residuals 
\begin_inset Formula $R_{i}^{1}$
\end_inset

 and 
\begin_inset Formula $R_{i}^{2}$
\end_inset

, which are row 
\begin_inset Formula $i$
\end_inset

 and row 
\begin_inset Formula $i+m$
\end_inset

 of the residual vector 
\begin_inset Formula $R$
\end_inset

.
 Similarly the value of 
\begin_inset Formula $x_{i}^{2}$
\end_inset

 in column 
\begin_inset Formula $i+m$
\end_inset

 will affect 
\begin_inset Formula $R_{i}^{1}$
\end_inset

 and 
\begin_inset Formula $R_{i}^{2}$
\end_inset

 in rows 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $i+m$
\end_inset

 of 
\begin_inset Formula $R$
\end_inset

.
 The pattern in the Jacobian that emerges for 
\begin_inset Formula $d=2$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{equation} 
\end_layout

\begin_layout Plain Layout

     P = 
\end_layout

\begin_layout Plain Layout


\backslash
left[
\end_layout

\begin_layout Plain Layout


\backslash
begin{array}{c;{2pt/2pt}c}         
\end_layout

\begin_layout Plain Layout

Q_{m} & Q_{m} 
\backslash

\backslash
 
\backslash
hdashline[2pt/2pt]         
\end_layout

\begin_layout Plain Layout

Q_{m} & Q_{m}     
\backslash
end{array} 
\end_layout

\begin_layout Plain Layout


\backslash
right] 
\backslash
end{equation}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "sec:Direct-Computation"

\end_inset


\end_layout

\begin_layout Standard
The policy function for the solution type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 is a spline as defined by Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 The default interpolation method is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cubic'}
\end_layout

\end_inset

, but can be set to any of the other types allowed by Matlab in the optional
 field 
\begin_inset Formula $POL.spl\_meth$
\end_inset

.
 The objective is to set the residual at each gridpoint to 0 by adjusting
 the policy variable at each gridpoint, 
\begin_inset Formula $\hat{y}_{t}^{i}$
\end_inset

.
\end_layout

\begin_layout Standard
To set the residuals to 0 we use the non-linear equation solver 
\family typewriter
fsolve
\family default
, which directly attempts to solve the complete system of equations.
 Once the stopping criteria for 
\family typewriter
fsolve
\family default
 are met we fit a spline through these points with 
\family typewriter
griddedInterpolant
\family default
.
\end_layout

\begin_layout Standard
It should be noted that 
\family typewriter
fsolve
\family default
 will numerically approximate the full Jacobian of the system of equations,
 which will be an 
\begin_inset Formula $\left(d\cdot m\right)\times\left(d\cdot m\right)$
\end_inset

  matrix, where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints, and 
\begin_inset Formula $d$
\end_inset

 the number of policy variables.
 This makes this method inefficient compared to Time Iteration, especially
 for large grids.
 
\end_layout

\begin_layout Standard
The reason we need to compute the full Jacobian is that a change in the
 policy variable at one gridpoint will change the spline.
 A change of the policy variable at gridpoint 
\begin_inset Formula $i$
\end_inset

 will therefore also affect the residuals at other gridpoints.
 
\end_layout

\begin_layout Chapter
Construction of grid
\begin_inset CommandInset label
LatexCommand label
name "chap:Grid"

\end_inset


\end_layout

\begin_layout Standard
The grid parameters, and also the grid itself are stored in the structure
 
\begin_inset Formula $GRID$
\end_inset

.
 It can be created with the function 
\family typewriter
prep_grid
\family default
, which takes the grid parameters and the solution method as inputs.
 The output is the structure 
\begin_inset Formula $GRID$
\end_inset

 which includes all the required fields.
\end_layout

\begin_layout Standard
The 
\family typewriter
prep_grid
\family default
 function is demonstrated in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with the example script 
\family typewriter
grid_example
\family default
 in the folder `PROMES_v04.3/Examples', which shows all the output variables
 (and intermediate variables).
 All functions of this chapter except 
\family typewriter
prep_grid
\family default
 are in the subfolder `PROMES_v04.3/grid_subfun'.
 This folder therefore needs to be on the searchpath to construct the grid.
\end_layout

\begin_layout Section
Function 
\family typewriter
prep_grid
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-`prep_grid'"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
prep_grid
\family default
 constructs structure 
\begin_inset Formula $GRID$
\end_inset

 with all the necessary fields.
 It mainly prepares the call to 
\begin_inset Formula $grid\textrm{\_}struct$
\end_inset

.
 The function 
\family typewriter
prep_grid
\family default
 takes five inputs:
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: the number of state variables;
\end_layout

\begin_layout Itemize
\begin_inset Formula $qq$
\end_inset

: vector of number of gridpoints in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $sol\textrm{\_}meth$
\end_inset

: the solution method, which should be assigned to 
\begin_inset Formula $POL.sol\textrm{\_}meth$
\end_inset

.
 The options are 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-'solve_proj'"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details).
\end_layout

\begin_layout Standard
For the polynomial methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 one can opt to specify the field:
\end_layout

\begin_layout Itemize
\begin_inset Formula $order$
\end_inset

 (optional): the order of the polynomial (scalar).
 If the field is not specified it will be set to the default 
\begin_inset Formula $order=5$
\end_inset

 for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, and to the default 
\begin_inset Formula $order=3$
\end_inset

 for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

.
 This optional field is ignored for methods using a spline (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
The function 
\family typewriter
prep_grid
\family default
 assigns the 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

, which is an input argument to the function 
\family typewriter
grid_struct
\family default
.
 The field 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 is set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 for solution methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

, to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 for solution method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 and to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

 for solution methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

.
 After assigning the 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 the function 
\family typewriter
prep_grid
\family default
 initializes the structure 
\begin_inset Formula $GRID$
\end_inset

 by calling the function 
\family typewriter
grid_struct
\family default
, which is explained in next section.
\end_layout

\begin_layout Section
Function 
\family typewriter
grid_struct
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:grid_struct"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
grid_struct
\family default
 is used to create a structure that contains all the necessary properties
 of the grid for a given grid method 
\begin_inset Formula $grid\_meth$
\end_inset

 , including the gridvectors, the full grid, and if required the complete
 polynomial of the grid.
\end_layout

\begin_layout Standard
The input arguments are: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: the number of state variables
\end_layout

\begin_layout Itemize
\begin_inset Formula $qq$
\end_inset

: vector of number of gridpoints in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $grid\_meth$
\end_inset

: either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 for Chebyshev polynomial with Chebyshev nodes, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 for monomial basis functions with equidistant nodes, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

 for an equidistant grid.
\end_layout

\begin_layout Standard
The function 
\family typewriter
grid_struct
\family default
 adds the input arguments 
\begin_inset Formula $nn$
\end_inset

, 
\begin_inset Formula $qq$
\end_inset

, 
\begin_inset Formula $lb$
\end_inset

, 
\begin_inset Formula $ub$
\end_inset

, and 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 as fields to 
\begin_inset Formula $GRID$
\end_inset

.
 In addition the following fields are added:
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs$
\end_inset

, and 
\begin_inset Formula $xx$
\end_inset

 which contain the initial gridvectors (see Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and a full grid (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

), respectively;
\end_layout

\begin_layout Itemize
\begin_inset Formula $XX$
\end_inset

 if the 
\begin_inset Formula $grid\_meth$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, which is the complete polynomial of the full grid 
\begin_inset Formula $xx$
\end_inset

 (see Section
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-polybase"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs\_dw$
\end_inset

, 
\begin_inset Formula $xx\_dw$
\end_inset

, and 
\begin_inset Formula $XX\_dw$
\end_inset

 if 
\begin_inset Formula $grid\_meth$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

.
 These are the scaled down versions of 
\begin_inset Formula $gridVecs$
\end_inset

, 
\begin_inset Formula $xx$
\end_inset

, and 
\begin_inset Formula $XX$
\end_inset

, respectively.
 The scaling down maps the variables linearly from 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 to 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The nodes are the Chebyshev nodes.
 For more details see Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-polybase"
plural "false"
caps "false"
noprefix "false"

\end_inset

, respectively.
\end_layout

\begin_layout Standard
These fields are are best explained with the example in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Example
\family typewriter
 grid_example
\begin_inset CommandInset label
LatexCommand label
name "sec:Grid_example"

\end_inset


\end_layout

\begin_layout Standard
We demonstrate the fields of the structure 
\begin_inset Formula $GRID$
\end_inset

 with the file 
\family typewriter
grid_example
\family default
, which prints some of the properties of the grid on screen.
 The function 
\family typewriter
grid_example
\family default
 can be found in the folder `PROMES_v04.3/Examples'.
 That example prints the various grid variables on screen.
 The code (excluding the printing commands) is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Folder = cd;%current path
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Add one folder up: folder with Promes toolkit 
\end_layout

\begin_layout Plain Layout

% (genpath includes all subfolders) 
\end_layout

\begin_layout Plain Layout

addpath (genpath(fullfile(Folder, '..')));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% Initializtion of grid parameters: 
\end_layout

\begin_layout Plain Layout

GRID.nn = 2;		%number of state variables
\end_layout

\begin_layout Plain Layout

GRID.qq = [3,4];	%number of nodes in each dim.
\end_layout

\begin_layout Plain Layout

GRID.lb = [1,10];	%lower bounds for [x1,x2] 
\end_layout

\begin_layout Plain Layout

GRID.ub = [2,30];	%upper bounds for [x1,x2]     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Set solution method 
\end_layout

\begin_layout Plain Layout

% ('gal','mse','tmi','dir' or 'mono'):
\end_layout

\begin_layout Plain Layout

sol_meth = 'mono';  
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

if strcmp(sol_meth,'mse') || strcmp(sol_meth,'gal') || strcmp(sol_meth,'mono')
 
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

  order = 2; 
\end_layout

\begin_layout Plain Layout

else         
\end_layout

\begin_layout Plain Layout

  order = []; 
\end_layout

\begin_layout Plain Layout

end      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Construct structure with grid: 
\end_layout

\begin_layout Plain Layout

[GRID] = prep_grid(GRID.nn,GRID.qq,GRID.lb,GRID.ub,sol_meth,order); 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Gridvectors
\end_layout

\begin_layout Standard
The function 
\family typewriter
grid_struct
\family default
 first constructs the gridvectors 
\begin_inset Formula $gridVecs$
\end_inset

, plus the scaled down versions in 
\begin_inset Formula $gridVecs\textrm{\_}dw$
\end_inset

 in case 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

.
 These gridvectors consist of either equidistant or Chebyshev nodes, with
 the specified amount of gridpoints on the interval determined by the lower
 and upper bound.
 The gridvectors are constructed using the function 
\family typewriter
constr_vecs
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The gridvectors will be added as fields to the structure 
\begin_inset Formula $GRID$
\end_inset

.
 
\end_layout

\begin_layout Standard
In the example we have specified that the state variables have 3 and 4 gridpoint
s, with bounds 
\begin_inset Formula $\left[1,3\right]$
\end_inset

 for 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $\left[10,25\right]$
\end_inset

 for 
\begin_inset Formula $x_{2}$
\end_inset

.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='mono'}
\end_layout

\end_inset

 the function 
\family typewriter
grid_struct
\family default
 will use equidistant nodes for the gridvectors.
 With equidistant nodes the resulting fields are 
\begin_inset Formula $gridVecs\{1,1\}=\left[\begin{array}{ccc}
1 & 2 & 3\end{array}\right]$
\end_inset

 for 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $gridVecs\{1,2\}=\left[\begin{array}{cccc}
10 & 15 & 20 & 25\end{array}\right]$
\end_inset

 for 
\begin_inset Formula $x_{2}$
\end_inset

, which are linearly spaced vectors from lower to upper bound with the specified
 amount of gridpoints.
 Note that these gridvectors are used for 
\begin_inset Formula $sol\_type$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For the methods using Chebyshev polynomials 
\family typewriter
prep_grid
\family default
 sets the 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, which means Chebyshev nodes are used.
 These nodes in the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 are added as 
\begin_inset Formula $gridVecs\textrm{\_}dw$
\end_inset

.
 The scaled down variables are constructed using the linear mapping from
 the lower and upper bounds 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 into 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 using.
 The linear map is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{x} & =\frac{2x}{ub-lb}-\frac{lb+ub}{ub-lb}\label{eq:Cheb_scal_dw-1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}$
\end_inset

 denotes the scaled down version (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
The scaled down nodes correspond to the roots of the Chebyshev polynomials.
 If there are 
\begin_inset Formula $q$
\end_inset

 nodes, then these nodes are the roots of the order 
\begin_inset Formula $q$
\end_inset

 polynomial.
 For example, for 
\begin_inset Formula $q=2$
\end_inset

 the nodes are the roots of the second order polynomial 
\begin_inset Formula $2\tilde{x}_{1}^{2}-1$
\end_inset

.
 These roots are 
\begin_inset Formula $\pm\frac{1}{2}\sqrt{2}$
\end_inset

.
 The minimum number of nodes in each dimension is therefore the order of
 the polynomial plus 1
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Otherwise the complete polynomial will contain a column vector with zeros.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In our case we have 
\begin_inset Formula $q=3$
\end_inset

 and 
\begin_inset Formula $q=4$
\end_inset

, which results in:
\begin_inset Formula 
\begin{align*}
gridVecs\textrm{\_}dw\{1,1\} & =\left[\begin{array}{ccc}
-0.866 & 0 & 0.866\end{array}\right]\\
gridVecs\textrm{\_}dw\{1,2\} & =\left[\begin{array}{cccc}
-0.924 & -0.383 & 0.383 & 0.924\end{array}\right]
\end{align*}

\end_inset

for 
\begin_inset Formula $\tilde{x}_{1}$
\end_inset

 and for 
\begin_inset Formula $\tilde{x}_{2}$
\end_inset

, respectively, as printed on screen.
 To scale up these vectors into the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 we use the inverse of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_scal_dw-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_up"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 These scaled up vectors are stored in the field 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $gridVecs$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Grid
\end_layout

\begin_layout Standard
After the gridvectors are constructed the function 
\family typewriter
prep_grid
\family default
 will construct the grid using the function 
\family typewriter
constr_grid
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which takes the gridvectors as input.
 The function constructs a full grid using 
\family typewriter
ndgrid
\family default
 and then transforms each output array into a column vector and stacks them
 next to each other to form a 
\begin_inset Formula $m\times n$
\end_inset

  matrix, with 
\begin_inset Formula $m$
\end_inset

 being the total number of nodes, and 
\begin_inset Formula $n$
\end_inset

 the number of state variables:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[x1,x2] = ndgrid(gridvecs{1,1},gridvecs{1,2});          
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

xx	= NaN(mm,nn);
\end_layout

\begin_layout Plain Layout

xx(:,1) = reshape(x1,[],1);     
\end_layout

\begin_layout Plain Layout

xx(:,2) = reshape(x2,[],1);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the gridvectors 
\begin_inset Formula $gridVecs\{1,1\}=\left[\begin{array}{ccc}
1 & 2 & 3\end{array}\right]$
\end_inset

 and 
\begin_inset Formula $gridVecs\{1,2\}=\left[\begin{array}{cccc}
10 & 15 & 20 & 25\end{array}\right]$
\end_inset

 the result with equidistant nodes is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
xx & =\left[\begin{array}{cccccccccccc}
1 & 2 & 3 & 1 & 2 & 3 & 1 & 2 & 3 & 1 & 2 & 3\\
10 & 10 & 10 & 15 & 15 & 15 & 20 & 20 & 20 & 25 & 25 & 25
\end{array}\right]^{\intercal}\label{eq:full_grid}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where each column (note the transpose) in 
\begin_inset Formula $x$
\end_inset

 represents a state variable, and each row is a unique gridpoint.
 
\end_layout

\begin_layout Standard
For the Chebyshev polynomials we construct a full grid for both the scaled
 up (
\begin_inset Formula $xx$
\end_inset

) and scaled down (
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

) variables, as printed on screen when the solution method is set to either
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Complete polynomials
\end_layout

\begin_layout Standard
For the grid types using polynomials (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='mono'}
\end_layout

\end_inset

) the function 
\family typewriter
prep_grid
\family default
 will construct complete polynomials using the function 
\family typewriter
polybase
\family default
, taking the full grid 
\begin_inset Formula $xx$
\end_inset

 or 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 as input.
 The call to construct a complete polynomial with monomial basis functions
 of order two is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

XX=polybase(GRID.xx,2,'mono');
\end_layout

\end_inset

The polynomial is constructed as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
XX & =\left[\begin{array}{cccccc}
1 & x_{1} & x_{2} & x_{1}^{2} & x_{1}x_{2} & x_{2}^{2}\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $x_{1}=xx\left(:,1\right)$
\end_inset

 and 
\begin_inset Formula $x_{2}=xx\left(:,2\right)$
\end_inset

 are the state variables in column vectors.
 The resulting complete polynomial 
\begin_inset Formula $XX$
\end_inset

 is printed on screen when the solution type 
\begin_inset Formula $sol\_type$
\end_inset

 is set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For Chebyshev polynomials only the scaled down grid 
\begin_inset Formula $\tilde{x}$
\end_inset

 (
\begin_inset Formula $GRID.xx\textrm{\_}dw$
\end_inset

) is used.
 A second order Chebyshev polynomial with two variables consists of the
 terms:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{X} & =\left[\begin{array}{cccccc}
1 & \tilde{x}_{1} & \tilde{x}_{2} & 2\tilde{x}_{1}^{2}-1 & \tilde{x}_{1}\tilde{x}_{2} & 2\tilde{x}_{2}^{2}-1\end{array}\right]\label{eq:Cheb_X_dw_2nd}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The scaled down complete polynomial with Chebyshev nodes will be printed
 on screen when 
\begin_inset Formula $sol\_meth$
\end_inset

 is set to either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
constr_vecs
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-`constr_vecs'"

\end_inset


\end_layout

\begin_layout Standard
This function constructs a cell array 
\begin_inset Formula $gridVecs$
\end_inset

, where each cell contains a vector of gridpoints (for state variable 
\begin_inset Formula $i$
\end_inset

 this is a 
\begin_inset Formula $1\times q\left(i\right)$
\end_inset

 vector).
 This function allows for either equidistant nodes (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='equi'}
\end_layout

\end_inset

) or Chebyshev nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='cheb'}
\end_layout

\end_inset

.
 In addition, one can choose for scaled up or scaled down variables, where
 scaled up variables are in the interval 
\begin_inset Formula $\left[lb\left(i\right),ub\left(i\right)\right]$
\end_inset

 and scaled down variables in the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 
\end_layout

\begin_layout Standard
When this function is called by 
\family typewriter
grid_struct
\family default
 it will either construct scaled up vectors with equidistant nodes when
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='equi'}
\end_layout

\end_inset

 or both scaled down and scaled up vectors when 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The inputs of the function are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $qq$
\end_inset

: vector of number of gridpoints in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $nod\_type$
\end_inset

: a string set to either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'equi'}
\end_layout

\end_inset

 for equidistant nodes, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 for Chebyshev nodes;
\end_layout

\begin_layout Itemize
\begin_inset Formula $scale\_type$
\end_inset

 (optional): a string which is either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'up'}
\end_layout

\end_inset

 (default for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='equi'}
\end_layout

\end_inset

) or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dw'}
\end_layout

\end_inset

 (default for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='cheb'}
\end_layout

\end_inset

), referring to scaled up variables (taking values between 
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

) or scaled down variables (taking values between 
\begin_inset Formula $-1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

), respectively;
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

 (not required for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='dw'}
\end_layout

\end_inset

): vector of lower bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

 (not required for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='dw'}
\end_layout

\end_inset

): vector of upper bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector).
\end_layout

\begin_layout Standard
The output of the function is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs$
\end_inset

: cell array containing the grid vector (either scaled up or scale down,
 depending on the 
\begin_inset Formula $scale\_type$
\end_inset

) in each dimension (cell array of 1 x 
\begin_inset Formula $nn$
\end_inset

, with the 
\begin_inset Formula $i$
\end_inset

th cell containing a row vector of length 
\begin_inset Formula $q$
\end_inset


\begin_inset Formula $\left(i\right)$
\end_inset

).
 
\end_layout

\begin_layout Standard
Note that when 
\family typewriter
grid_struct
\family default
 calls this function with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='dw'}
\end_layout

\end_inset

 then the output will assigned to 
\begin_inset Formula $GRID.gridVecs\_dw$
\end_inset

.
\end_layout

\begin_layout Standard
The function 
\family typewriter
constr_vecs
\family default
 uses the functions:
\end_layout

\begin_layout Itemize

\family typewriter
chebnodes
\family default
 (for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

), which returns the Chebyshev nodes (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-chebnodes"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_dw 
\family default
(for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='dw'}
\end_layout

\end_inset

): see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_up
\family default
 (for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

 in combination with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='up'}
\end_layout

\end_inset

): see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_up"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
constr_grid
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-`constr_grid'"

\end_inset


\end_layout

\begin_layout Standard
This function constructs a full grid, using the 
\begin_inset Formula $n$
\end_inset

 gridvectors in the cell array 
\begin_inset Formula $gridVecs$
\end_inset

 as input.
 The output is an 
\begin_inset Formula $m\times n$
\end_inset

  matrix, where each column vector is a state variable, and each row represents
 a unique gridpoint.
 The function constructs a grid with Matlab's 
\family typewriter
ndgrid
\family default
, where each grid vector is expanded into a 
\begin_inset Formula $n$
\end_inset

 dimensional array.
 These arrays are reshaped into in column vectors, which are stacked next
 to each other.
\end_layout

\begin_layout Standard
The inputs of the function is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs$
\end_inset

: a  
\begin_inset Formula $1\times n$
\end_inset

 cell array, as described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It should be noted that 
\begin_inset Formula $gridVecs$
\end_inset

 can contain either scaled up or scaled down variables.
\end_layout

\begin_layout Standard
The output of the function is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: a matrix containing unique gridpoints in each row, and each column a dimension
 of the grid (
\begin_inset Formula $m\times n$
\end_inset

 matrix).
 Note that 
\begin_inset Formula $xx$
\end_inset

 can be either scaled up or down 
\begin_inset Foot
status open

\begin_layout Plain Layout
The labeling as either 
\begin_inset Formula $xx$
\end_inset

 or 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 is done in the function 
\family typewriter
grid_struct
\family default
.
\end_layout

\end_inset

;
\end_layout

\begin_layout Section
Function 
\family typewriter
polybase
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-polybase"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
polybase
\family default
 constructs a complete polynomial of the grid, using either Chebyshev (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{poly_type='cheb'}
\end_layout

\end_inset

) or monomial basis (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{poly_type='mono'}
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: a matrix of the gridpoints (either scaled up or scaled down);
\end_layout

\begin_layout Itemize
\begin_inset Formula $order$
\end_inset

: the order of the polynomial (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`prep_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $poly\textrm{\_}type$
\end_inset

: a string either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 (default).
 For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{type='cheb'}
\end_layout

\end_inset

 the polynomial version of the grid is created using Chebyshev polynomials.
 If set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{type='mono'}
\end_layout

\end_inset

 monomial basis functions are used.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $XX$
\end_inset

: the complete polynomial of the grid 
\begin_inset Formula $xx$
\end_inset

;
\end_layout

\begin_layout Subsection*
Complete polynomials
\end_layout

\begin_layout Standard
An example of complete polynomials 
\begin_inset CommandInset citation
LatexCommand citep
after "for a definition"
before "see"
key "judd1998numerical"
literal "false"

\end_inset

 with two variables, 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 are as follows.
 For the monomial basis functions the third order polynomial is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
XX & =\left[\begin{array}{cccccccccc}
1 & x_{1} & x_{2} & x_{1}^{2} & x_{1}x_{2} & x_{2}^{2} & x_{1}^{3} & x_{1}^{2}x_{2} & x_{1}x_{2}^{2} & x_{2}^{3}\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 are column vectors (see function 
\family typewriter
constr_grid
\family default
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The Chebyshev polynomial (of the first type) of order two is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
XX & =\left[\begin{array}{cccccc}
1 & \tilde{x}_{1} & \tilde{x}_{2} & 2\tilde{x}_{1}^{2}-1 & \tilde{x}_{1}\tilde{x}_{2} & 2\tilde{x}_{2}^{2}-1\end{array}\right]\label{eq:Cheb_poly}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}_{1}$
\end_inset

 and 
\begin_inset Formula $\tilde{x}_{2}$
\end_inset

 are column vectors of the scaled down variables (see function 
\family typewriter
constr_grid
\family default
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
Function 
\family typewriter
scal_mat_up
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-scal_mat_up"

\end_inset


\end_layout

\begin_layout Standard
The function takes a scaled down grid 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 and scales it up to output 
\begin_inset Formula $xx$
\end_inset

, using 
\family typewriter
sc_cheb_up
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: scaled down grid (
\begin_inset Formula $m\times n$
\end_inset

 matrix) (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: a is scaled up grid ( 
\begin_inset Formula $m\times n$
\end_inset

 matrix), with each column 
\begin_inset Formula $i$
\end_inset

 in 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 linearly transformed using 
\family typewriter
sc_cheb_up
\family default
, using bounds 
\begin_inset Formula $lb\left(i\right)$
\end_inset

 and 
\begin_inset Formula $ub\left(i\right)$
\end_inset

.
\end_layout

\begin_layout Standard
The function uses:
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_up
\family default
, which is explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_up"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
sc_cheb_up
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-sc_cheb_up"

\end_inset


\end_layout

\begin_layout Standard
This function uses a linear transformation of a variable of the form 
\begin_inset Formula $xx=(xx\textrm{\_}dw+1)(ub-lb)/2+lb$
\end_inset

.
 This means a variable 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 with the basis interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 is linearly mapped to the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Values can be outside the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

, which results in 
\begin_inset Formula $xx$
\end_inset

 also being outside 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

.
\end_layout

\end_inset

.
 This is the inverse transformation of the function 
\family typewriter
sc_cheb_dw
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

: the lower and upper bound (both scalars) of variable 
\begin_inset Formula $xx$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: an array of gridpoints for one variable based on the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: an array of one variable with the same dimensions as 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 and scaled up to the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
scal_mat_dw
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-scal_mat_dw"

\end_inset


\end_layout

\begin_layout Standard
The function takes a scaled up grid (
\begin_inset Formula $xx$
\end_inset

 ) and scales it down (output 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

) using 
\family typewriter
sc_cheb_dw
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: scaled up grid (
\begin_inset Formula $m\times n$
\end_inset

 matrix) (see Section
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: a is scaled down grid (
\begin_inset Formula $m\times n$
\end_inset

 matrix), with each column in 
\begin_inset Formula $xx\left(i\right)$
\end_inset

 linearly transformed using 
\family typewriter
sc_cheb_dw
\family default
, using bounds 
\begin_inset Formula $lb\left(i\right)$
\end_inset

 and 
\begin_inset Formula $ub\left(i\right)$
\end_inset

.
\end_layout

\begin_layout Standard
The function uses:
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_dw
\family default
, which is explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
sc_cheb_dw
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-sc_cheb_dw"

\end_inset


\end_layout

\begin_layout Standard
This function linearly transforms a variable with the formula 
\begin_inset Formula $xx\textrm{\_}dw=2xx/(ub-lb)-(lb+ub)/(ub-lb)$
\end_inset

.
 A variable 
\begin_inset Formula $xx$
\end_inset

 based on the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 is linearly mapped to interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Values can be outside the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

, which results in 
\begin_inset Formula $xx$
\end_inset

 also being outside 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\end_inset

.
 This is the inverse transformation of the function 
\family typewriter
sc_cheb_up
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

: the lower and upper bound (both scalars) of variable 
\begin_inset Formula $xx$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: an array (of any dimension) of gridpoints for one variable based on the
 interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: an array of one variable with the same dimensions as 
\begin_inset Formula $xx$
\end_inset

 and scaled down to the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
chebnodes
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-chebnodes"

\end_inset


\end_layout

\begin_layout Standard
This function constructs a column vector of the Chebyshev nodes in the range
 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The input is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $dd$
\end_inset

: the number of nodes.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $x$
\end_inset

: a column vector (
\begin_inset Formula $dd$
\end_inset

 x 1) of the Chebyshev nodes in the range 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\begin_layout Part
Example models
\begin_inset CommandInset label
LatexCommand label
name "part:Example-models"

\end_inset


\end_layout

\begin_layout Chapter
Deterministic Brock-Mirman model
\begin_inset CommandInset label
LatexCommand label
name "chap:Description-det-BM"

\end_inset


\end_layout

\begin_layout Standard
The Brock-Mirman model was used in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:The-Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a simple example.
 In this chapter we describe the derivation of the equations used there.
 The Brock-Mirman model is interesting, because the optimal solution can
 be derived analytically, even for the stochastic version.
 We used the deterministic version for simplicity reasons.
 
\end_layout

\begin_layout Standard
The agent in the Brock-Mirman model maximizes his discounted utility :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max & \sum_{t=1}^{\infty}\beta^{t-1}\log\left(C_{t}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
subject to:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
K_{t+1}+C_{t} & =K_{t}^{\alpha}\label{eq:BM-budget2}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C_{t}$
\end_inset

 is consumption in period 
\begin_inset Formula $t$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

 is the discount factor, 
\begin_inset Formula $K_{t}$
\end_inset

 is the capital stock 
\shape italic
at the beginning
\shape default
 of the period, and 
\begin_inset Formula $K_{t}^{\alpha}$
\end_inset

 is the production function.
\end_layout

\begin_layout Standard
We rewrite the maximization problem in a infinite horizon Lagrangian:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathcal{L} & =\sum_{t=1}^{\infty}\beta^{t-1}\left\{ \log\left(C_{t}\right)+\lambda_{t}\left[K_{t}^{\alpha}-K_{t+1}-C_{t}\right]\right\} 
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\lambda_{t}$
\end_inset

 is the Lagrangian multiplier on the resource constraint.
 The solution is an infinite series for 
\begin_inset Formula $C_{t}$
\end_inset

, 
\begin_inset Formula $K_{t+1}$
\end_inset

, and 
\begin_inset Formula $\lambda_{t}$
\end_inset

.
 The sufficient First Order Conditions with respect to 
\begin_inset Formula $C_{t}$
\end_inset

, and 
\begin_inset Formula $K_{t+1}$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{1}{C_{t}} & =\lambda_{t}\label{eq:BM-FOC_c}\\
\lambda_{t} & =\beta\lambda_{t+1}\alpha K_{t+1}^{\alpha-1}\nonumber 
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The second equation is referred to as the Euler equation, and characterizes
 the dynamic solution.
 We can substitute out 
\begin_inset Formula $\lambda$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-FOC_c"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and obtain: 
\begin_inset Formula 
\begin{align}
\frac{1}{C_{t}} & =\beta\frac{1}{C_{t+1}}\alpha K_{t+1}^{\alpha-1}\label{eq:BM-Eul}
\end{align}

\end_inset


\end_layout

\begin_layout Subsection*
Analytical solution
\end_layout

\begin_layout Standard
The model has an analytical solution, which is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
C_{t} & =\left(1-\alpha\beta\right)K_{t}^{\alpha}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
With this policy function next period's capital stock is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
K_{t+1} & =K_{t}^{\alpha}-\left(1-\alpha\beta\right)K_{t}^{\alpha}\\
 & =\left(\alpha\beta\right)K_{t}^{\alpha}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Substituting this into the The Euler equation yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{1}{\left(1-\alpha\beta\right)K_{t}^{\alpha}} & =\beta\frac{1}{\left(1-\alpha\beta\right)\left[\left(\alpha\beta\right)K_{t}^{\alpha}\right]^{\alpha}}\alpha\left[\left(\alpha\beta\right)K_{t}^{\alpha}\right]^{\alpha-1}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which proofs that both equations are satisfied for the given solution.
\end_layout

\begin_layout Subsection*
Steady state
\end_layout

\begin_layout Standard
From the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-Eul"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we derive steady state capital:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{K} & =\left[\alpha\beta\right]^{\frac{1}{1-\alpha}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
and from the resource constraint 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:BM-budget2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we derive steady state consumption:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C} & =\overline{K}^{\alpha}-\delta\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Chapter
Standard RBC model
\begin_inset CommandInset label
LatexCommand label
name "chap:Standard_RBC_model"

\end_inset


\end_layout

\begin_layout Standard
In Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we used a standard Real Business Cycle (RBC) as an example.
 In this chapter we derive the equations used in that chapter.
 This includes the computation of the expected value using Gauss-Hermite
 quadrature.
\end_layout

\begin_layout Section
Model
\begin_inset CommandInset label
LatexCommand label
name "sec:Full-model-description"

\end_inset


\end_layout

\begin_layout Standard
A standard Real Business Cycle (RBC) model with a representative agent is
 a dynamic model where the agent has to determine how much to work, consume
 and invest.
 Hours worked gives disutility, consumption gives instant positive utility,
 while investment increases future capital income.
\end_layout

\begin_layout Standard
The objective function of the agent is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max\: & E_{1}\underset{{\scriptstyle t=1}}{\overset{{\scriptstyle \infty}}{\sum}}\beta^{t-1}\frac{C_{t}^{1-\nu}}{1-\nu}-\chi\frac{H_{t}^{1+\frac{1}{\eta}}}{1+\frac{1}{\eta}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C_{t}$
\end_inset

 is period 
\begin_inset Formula $t$
\end_inset

 consumption, and 
\begin_inset Formula $H_{t}$
\end_inset

 is period 
\begin_inset Formula $t$
\end_inset

 labor supply.
 The real budget constraint is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1} & =Z_{t}K_{t}^{\alpha}H_{t}^{1-\alpha}+\left(1-\delta\right)K_{t}\label{eq:Budget_constraint}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $K_{t}$
\end_inset

 is the capital stock at the beginning of period 
\begin_inset Formula $t$
\end_inset

, and 
\begin_inset Formula $\delta$
\end_inset

 is the depreciation rate of capital.
 Total Factor Productivity (TFP) 
\begin_inset Formula $Z_{t}$
\end_inset

 evolves by an exogenous process:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
z_{t} & =\rho_{z}z_{t-1}+\sigma_{z}\epsilon_{t}\label{eq:TFP_process}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $z_{t}=\log\left(Z_{t}\right)$
\end_inset

, 
\begin_inset Formula $\rho_{z}$
\end_inset

 is the autocorrelation coefficient, and 
\begin_inset Formula $\sigma_{z}$
\end_inset

 is the standard deviation of the shocks.
 The shocks 
\begin_inset Formula $\epsilon_{t}$
\end_inset

 are standard normally distributed (
\begin_inset Formula $\epsilon_{t}\sim\mathcal{N}\left(0,1\right)$
\end_inset

).
\end_layout

\begin_layout Standard
The optimization problem can be written with an infinite Lagrangian:
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{L}=E\overset{{\scriptscriptstyle \infty}}{\underset{{\scriptscriptstyle t=1}}{\sum}}\beta^{t}\left\{ \frac{C_{t}^{1-\nu}}{1-\nu}-\chi\frac{H_{t}^{1+\frac{1}{\eta}}}{1+\frac{1}{\eta}}+\lambda_{t}\left[Z_{t}K_{t}^{\alpha}H_{t}^{1-\alpha}+\left(1-\delta\right)K_{t}-C_{t}-K_{t+1}\right]\right\} $
\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\lambda_{t}$
\end_inset

 is the shadow price of the budget constraint, and 
\begin_inset Formula $K_{1}$
\end_inset

 is given.
 Maximization of this Lagrangian with respect to hours 
\begin_inset Formula $H_{t}$
\end_inset

, consumption 
\begin_inset Formula $C_{t}$
\end_inset

 and capital in next period 
\begin_inset Formula $K_{t+1}$
\end_inset

 yields the following First Order Conditions:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
C_{t}^{-\nu} & =\lambda_{t}\\
\chi H_{t}^{\frac{1}{\eta}} & =\lambda_{t}Z_{t}\left(1-\alpha\right)K_{t}^{\alpha}H_{t}^{-\alpha}\\
\lambda_{t} & =\beta\lambda_{t+1}\left[F_{k}\left(K_{t},H_{t}\right)+1-\delta\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Substituting out 
\begin_inset Formula $\lambda$
\end_inset

 gives:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\chi H_{t}^{\frac{1}{\eta}} & =C_{t}^{-\nu}Z_{t}\left(1-\alpha\right)K_{t}^{\alpha}H_{t}^{-\alpha}\label{eq:Lab_supply}\\
C_{t}^{-\nu} & =\beta E_{t}\left\{ C_{t+1}^{-\nu}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}H_{t+1}^{1-\alpha}+1-\delta\right]\right\} \label{eq:Euler_eq}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We can derive an analytical expression for labor supply, given capital,
 TFP and consumption using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Lab_supply"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
H_{t} & =\left[\frac{1-\alpha}{\chi}C_{t}^{-\nu}Z_{t}K_{t}^{\alpha}\right]^{\frac{\eta}{1+\alpha\eta}}\label{eq:RBC_lab_sol}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
To calculate the right-hand-side of the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (for a given policy function) we need to calculate 
\begin_inset Formula $\hat{c}_{t+1}=\hat{c}\left(\hat{k}_{t+1},z_{t+1};\theta\right)$
\end_inset

 and 
\begin_inset Formula $\hat{h}_{t+1}=H\left(\hat{c}_{t+1},\hat{k}_{t+1},z_{t+1}\right)$
\end_inset

.
 After substituting out 
\begin_inset Formula $\hat{k}_{t+1}$
\end_inset

 and 
\begin_inset Formula $\hat{c}_{t+1}$
\end_inset

 the right-hand-side of the Euler equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Euler_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is a function of 
\begin_inset Formula $k_{t},z_{t}$
\end_inset

, 
\begin_inset Formula $z_{t+1}$
\end_inset

, and the vector of parameters 
\begin_inset Formula $\theta$
\end_inset

.
 We can simplify the notation for the right-hand-side of the Euler equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
E_{t}\left\{ \beta C_{t+1}^{-\nu}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}H_{t+1}^{1-\alpha}+1-\delta\right]\right\}  & \approx E_{t}P\left(k_{t},z_{t},z_{t+1};\theta\right)\label{eq:RHS-2}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We use Gauss-Hermite quadrature to approximate this expression as explained
 in the next section.
 
\end_layout

\begin_layout Section
Gauss-Hermite quadrature
\begin_inset CommandInset label
LatexCommand label
name "sec:RBC_quadrature"

\end_inset


\end_layout

\begin_layout Standard
To approximate expression 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RHS-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we use Gauss-Hermite quadrature.
 The general rule for Gaussian-Hermite approximation is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\intop_{-\infty}^{\infty}\exp\left(-x^{2}\right)f\left(x\right)dx & \approx\sum_{j=1}^{J}\omega_{j}f\left(x_{j}\right)\label{eq:Gauss-Hermite-2}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
with Gauss-Hermite nodes 
\begin_inset Formula $j=1,...,J$
\end_inset

, with roots 
\begin_inset Formula $x_{j}$
\end_inset

 and weights 
\begin_inset Formula $\omega_{j}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
before "see"
key "judd1998numerical"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Since the shocks are standard normally distributed (
\begin_inset Formula $\epsilon_{t}\sim\mathcal{N}\left(0,1\right)$
\end_inset

) the expectation is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
E_{t}P\left(k_{t},z_{t},z_{t+1};\theta\right) & =\intop_{-\infty}^{\infty}P\left(k_{t},z_{t},\rho_{z}z_{t}+\sigma_{z}\epsilon_{t+1};\theta\right)\frac{1}{\sqrt{2\pi}}\exp\left(-\epsilon_{t+1}^{2}/2\right)d\epsilon_{t+1}\label{eq:Exp_RHS-2}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
To write 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Exp_RHS-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in the form of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Gauss-Hermite-2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we need a change of variable: 
\begin_inset Formula $\phi=\frac{\epsilon_{t+1}}{\sqrt{2}}$
\end_inset

, such that 
\begin_inset Formula $\exp\left(-\epsilon_{t+1}^{2}/2\right)=\exp\left(-\phi^{2}\right)$
\end_inset

.
 The integral can be written as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{multline*}
\intop_{-\infty}^{\infty}P\left(k_{t},z_{t},\rho_{z}z_{t}+\sigma_{z}\sqrt{2}\phi;\theta\right)\frac{1}{\sqrt{2\pi}}\exp\left(\phi\right)\sqrt{2}d\phi\\
=\sum_{j=1}^{J}\frac{\omega_{j}}{\sqrt{\pi}}P\left(k_{t},z_{t},\rho_{z}z_{t}+\sigma_{z}\sqrt{2}\zeta_{j};\theta\right)
\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where the extra term
\begin_inset Formula $\sqrt{2}$
\end_inset

 (before 
\begin_inset Formula $d\phi$
\end_inset

) follows from integration by substitution.
\end_layout

\begin_layout Section
Steady state
\begin_inset CommandInset label
LatexCommand label
name "sec:RBC_steady-state"

\end_inset


\end_layout

\begin_layout Standard
To derive the analytical steady state we start with the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_eq"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C}^{-\nu} & =\beta\left\{ \overline{C}^{-\nu}\left[\overline{Z}\alpha\overline{K}^{\alpha-1}H^{1-\alpha}+1-\delta\right]\right\} \\
\overline{H} & =\left[\frac{1-\beta\left(1-\delta\right)}{\overline{Z}\alpha\beta}\right]^{\frac{1}{1-\alpha}}\overline{K}=\Omega^{\frac{1}{1-\alpha}}\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
with 
\begin_inset Formula $\Omega=\frac{1-\beta\left(1-\delta\right)}{\alpha\beta\overline{Z}}$
\end_inset

.
\end_layout

\begin_layout Standard
Substituting this into the resource constraint 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Budget_constraint"
plural "false"
caps "false"
noprefix "false"

\end_inset

 yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C}+\overline{K} & =\overline{Z}\overline{K}^{\alpha}\overline{H}^{1-\alpha}+\left(1-\delta\right)\overline{K}\\
\overline{C} & =\overline{Z}\overline{K}^{\alpha}\left[\Omega^{\frac{1}{1-\alpha}}\overline{K}\right]^{1-\alpha}-\delta\overline{K}\\
 & =\left(\overline{Z}\Omega-\delta\right)\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Substituting the expressions for 
\begin_inset Formula $\overline{H}$
\end_inset

 and 
\begin_inset Formula $\overline{C}$
\end_inset

 into the labor supply function 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Lab_supply"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and solving for 
\begin_inset Formula $\overline{K}$
\end_inset

 yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{K} & =\left[\left(\frac{1-\alpha}{\chi}\overline{Z}\left[\overline{Z}\Omega-\delta\right]^{-\nu}\right)^{\eta}\Omega^{\frac{\alpha\eta+1}{\alpha-1}}\right]^{\frac{1}{1+\eta\nu}}
\end{align*}

\end_inset


\end_layout

\begin_layout Chapter
Housing model
\begin_inset CommandInset label
LatexCommand label
name "chap:Housing-model"

\end_inset


\end_layout

\begin_layout Standard
In Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we used an RBC model with housing to demonstrate how to solve a model with
 two policy variables.
 In this chapter we describe the model and the derivations of the equations.
 
\end_layout

\begin_layout Subsection*
Model
\end_layout

\begin_layout Standard
The objective of the agent is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max\: & E_{1}\sum_{t=1}^{\infty}\beta^{t-1}\left[U\left(C_{t}\right)+V\left(D_{t}\right)\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C$
\end_inset

 is consumption, and 
\begin_inset Formula $D$
\end_inset

 is housing.
 The agent maximizes the objective subject to the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1}+D_{t+1} & \leq Z_{t}K_{t}^{\alpha}+\left(1-\delta_{k}\right)K_{t}+\left(1-\delta_{d}\right)D_{t}\label{eq:HOUS_budget}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The First Order Conditions for 
\begin_inset Formula $C_{t}$
\end_inset

, 
\begin_inset Formula $K_{t+1}$
\end_inset

, and 
\begin_inset Formula $D_{t+1}$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
U'\left(C_{t}\right) & =\lambda_{t}\nonumber \\
\lambda_{t} & =\beta E_{t}\left\{ \lambda_{t+1}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}+1-\delta_{k}\right]\right\} \label{eq:HOUS_eul_k}\\
\lambda_{t} & =\beta E_{t}\left\{ V'\left(D_{t+1}\right)+\lambda_{t+1}\left(1-\delta_{d}\right)\right\} \label{eq:HOUS_eul_h}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We use the functional form: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
U\left(C_{t}\right) & =\frac{C_{t}^{1-\nu}-1}{1-\nu}\\
V\left(D_{t}\right) & =\varrho\frac{D_{t}^{1-\eta}-1}{1-\eta}
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection*
Steady state
\end_layout

\begin_layout Standard
The Euler equation for capital 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_k"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is standard and yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
1 & =\beta\left(\overline{Z}\alpha\overline{K}^{\alpha-1}+1-\delta_{k}\right)\\
\overline{K} & =\left(\frac{\overline{Z}\alpha\beta}{1-\beta\left(1-\delta_{k}\right)}\right)^{\frac{1}{1-\alpha}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
From the Euler equation for housing 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_h"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we derive:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
V'\left(\overline{D}\right) & =\overline{\lambda}\frac{1-\beta\left(1-\delta_{d}\right)}{\beta}\\
\varrho\overline{D}^{-\eta} & =\overline{C}^{-\nu}\frac{1-\beta\left(1-\delta_{d}\right)}{\beta}\\
\overline{D} & =\left(\frac{1-\beta\left(1-\delta_{d}\right)}{\varrho\beta}\right)^{\frac{1}{-\eta}}\overline{C}^{\frac{\nu}{\eta}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
And finally from the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C}+\delta_{k}\overline{K}+\delta_{d}\overline{D} & =\overline{Z}\overline{K}^{\alpha}\\
\overline{C}+\delta_{d}\left(\frac{1-\beta\left(1-\delta_{k}\right)}{\varrho\beta}\right)^{\frac{1}{-\eta}}\overline{C}^{\frac{\nu}{\eta}} & =\overline{Z}\overline{K}^{\alpha}-\delta_{k}\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We solve for 
\begin_inset Formula $\overline{C}$
\end_inset

 and 
\begin_inset Formula $\overline{D}$
\end_inset

 numerically using a non-linear equation solver.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "../../../REFERENCES/Macro_refer"
options "bibtotoc"

\end_inset


\end_layout

\end_body
\end_document
